[{"id":0,"href":"/%E5%B7%A5%E5%85%B7/%E6%8A%80%E5%B7%A7/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"搜索引擎的使用","section":"技巧","content":"======= 常用的指令 =======\n1. \u0026quot; (双引号) #  把搜索词放在双引号（英文半角）中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。Google和百度都支持这个指令。 例如：\n \u0026ldquo;seo方法图片\u0026rdquo;\n 2. - (减号) #  代表搜索不包含减号后面的词的页面。使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。Google和百度都支持这个指令。 例如：\n 搜索 -引擎\n 返回的结果中包含搜索但不包含引擎\n3. * (星号) #  是常用的通配符，也可以用在搜索中。百度不支持 * 号搜索指令。 例如：\n 搜索*擎\n 其中的*号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。\n4. ~(波浪线) #  代表搜索包含这个词以及合适的近义词的页面。貌似百度不支持该搜索指令 例如：\n ~elderly\n 所得到的页面就会不仅是包括“elderly”这个词，还会有包括“senior”、“older”、“aged”等等词的页面。\n5. inurl #  inurl: 指令用于搜索查询词出现在url 中的页面，inurl 指令支持中文和英文。百度和Google都支持这个指令。 例如：\n inurl:搜索引擎优化\n 返回的结果都是网址url 中包含“搜索引擎优化”的页面。由于关键词出现在url 中对排名有一定影响，使用inurl:搜索可以更准确地找到竞争对手。\n6. inanchor #  inanchor:指令返回的结果是导入链接锚文字中包含搜索词的页面。百度不支持inanchor。 例如：\n inanchor:点击这里\n 返回的结果页面本身并不一定包含“点击这里”这四个字，而是指向这些页面的链接锚文字中出现了“点击这里”这四个字。\n7. intitle #  intitle: 指令返回的是页面title 中包含关键词的页面。Google和百度都支持这个指令。 使用intitle 指令找到的文件是更准确的竞争页面。如果关键词只出现在页面可见文字中，而没有出现在title 中，大部分情况是并没有针对关键词进行优化，所以也不是有力的竞争对手。\n8. allintitle #  allintitle:搜索返回的是页面标题中包含多组关键词的文件，Google和百度都支持这个指令。 例如：\n allintitle:SEO 搜索引擎优化\n 就相当于：intitle:SEO intitle:搜索引擎优化，返回的是标题中中既包含“SEO”，也包含“搜索引擎优化”的页面\n9. allinurl #  与allintitle: 类似，Google和百度都支持这个指令。 例如：\n allinurl:SEO 搜索引擎优化\n 就相当于：inurl:SEO inurl:搜索引擎优化\n10. filetype #  用于搜索特定文件格式，Google和百度都支持这个指令。 例如：\n filetype:pdf SEO\n 返回的就是包含SEO 这个关键词的所有pdf 文件。\n11. site #  site:是SEO 最熟悉的高级搜索指令，用来搜索某个域名下的所有文件，Google和百度都支持这个指令。\n site: http://cnseotool.com\n 12. linkdomain #  linkdomain:指令只适用于雅虎，返回的是某个域名的反向链接。雅虎的反向链接数据还比较准 确，是SEO 人员研究竞争对手外部链接情况的重要工具之一。 例如：\n linkdomain: http://cnseotool.com -site: http://cnseotool.com\n 得到的就是点石网站的外部链接，因为-site: http://cnseotool.com 已经排除了点石本身的页面，也就是内部 链接，剩下的就都是外部链接了。\n13. related #  related:指令只适用于Google，返回的结果是与某个网站有关联的页面。 例如：\n related: http://cnseotool.com\n 我们就可以得到Google 所认为的与点石网站有关联的其他页面。 这种关联到底指的是什么，Google 并没有明确说明，一般认为指的是有共同外部链接的网站。\n"},{"id":1,"href":"/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E4%B8%AA%E6%80%A7%E5%8C%96%E7%9A%84%E8%AE%BE%E7%BD%AE/","title":"个性化的设置","section":"Dokuwiki","content":"dokuwiki 的个性化设置 #  添加侧边栏 #  有的主题是默认带有侧边栏的，而我使用的 Bootstrap3 主题带有右侧边栏，其显示当前文章的内容的索引，想要显示整个 wiki 的索引还需要使用插件 start#IndexMenu。 插件的添加与使用请参考其文档，这里介绍如何使其成为独立的侧边栏。\n 添加一个名为 sidebar 的页面。注：这是默认的名字，如果修改了配置中的 基本配置-\u0026gt;sidebar 的配置，需要与其修改后的名字一致 编辑该页面，添加如下语句，保存即可。   {{indexmenu\u0026gt;..#1|js navbar nocookie}}  在侧边栏中隐藏 sidebar 和 start 页面 #  上面方法添加的侧边栏中会把 sidebar 和 start 页面显示出来，如果不想显示，则将 sidebar 页面中的语句修改成下面的即可\n {{indexmenu\u0026gt;..#1 |js#bj-tango.png navbar max#3#2 skipfile+/(^|:)(start|sidebar)$/ skipns=/^users$/}}  注：上面的语句还隐藏了 users 名字空间，如果想显示，则将 skipns=/^users$/ 删掉即可。\n修改上传附件大小为2M限制 #  修改 /etc/php.ini 中的两个参数\n upload_max_filesize = 10M post_max_size = 10M  注: Windows环境中尽管会提示上传文件过大，但好像实际并不会限制上传。\n替换图标 #  替换 dokuwiki/lib/tpl/dokuwiki/images/ 路径下的文件：\n logo.png 界面的图标\n* favicon.ico 浏览器标签上的图标  修改页脚 #  修改文件 dokuwiki/lib/tpl/dokuwiki/tpl_footer.php\n修改时区 #  dokuwiki #  修改 dokuwiki/inc/init.php 文件中的\ndate_default_timezone_set('PRC')  注：PRC 标识中国时区\nphp #  修改 php.ini 文件，找到下面部分\n[Date] ; Defines the default timezone used by the date functions ; http://php.net/date.timezone ;date.timezone = date.timezone = Asia/Shanghai  重启 web 服务即可。\n修改上传文件格式的限制 #   系统默认支持类型：修改 dokuwiki/conf/mime.conf，在里面增加或注释掉对应的文件格式即可。 用户自定义类型：修改 dokuwiki/conf/mime.local.conf。  使用自定义的邮箱发送邮件 #   勾选管理 \u0026ndash;\u0026gt; 配置设置 \u0026ndash;\u0026gt; 通知设置 中 启用页面订阅支持 在 自动发送邮件时使用的邮件地址 中输入要使用的邮箱，例：email@email.com 也可以增加配置 自动发送邮件时使用的邮件地址前缀，使其在所有发送邮件的主题添加这个前缀，方便过滤邮件。  上面的配置使用的是 php 的内置邮件功能，当其不可用时可以添加插件 start#smtp来提供邮件功能\n 添加插件 smtp。 设置 smtp，设置的路径为 管理 \u0026ndash;\u0026gt; 配置设置 \u0026ndash;\u0026gt; Smtp  在邮箱运营商那里找到相应的 stmp 地址、端口与加密方式，将其分别填入您的 SMTP 发送服务器、您的 SMTP 服务器监听端口、您的 SMTP 服务器所用的加密类型 在 如果需要认证，在这里输入您的用户名 中输入邮箱 email@email.com，注意：此用户名必须与上面的 自动发送邮件时使用的邮件地址 中的设置的邮箱相同 对应上面用户名的密码 为 password 保存即可。    参考资料 #   dokuwiki插件的常用配置及其他Tips\nDokuWiki 用户手册\n玩转Dokuwiki\nDokuWiki相关\n"},{"id":2,"href":"/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/","title":"安装与部署","section":"Dokuwiki","content":"系统要求 #  1. 支持 PHP 的 Web 服务器\n2. PHP 至少是 5.6 版本以上的，最好是最新的版本\n详细要求可参阅 官网的相关说明\n下载 #  在 官网下载最新稳定版的压缩包\nWeb 服务的配置 #  在 官网中的 Webserver Specifics有提供了几款常见的 web 服务器的配置，在这里只展示了我用的 nginx 的配置\nnginx #  添加配置文件 /etc/nginx/conf.d/dokuwiki.conf\nserver {  listen 443 ssl;  server_name wiki.mydomain.com;  root /var/www/html/dokuwiki;  index index.html index.php doku.php;   access_log /var/log/nginx/dokuwiki.access.log;  error_log /var/log/nginx/dokuwiki.error.log;   ssl on;  ssl_certificate /etc/letsencrypt/live/wiki.mydomain.com/fullchain.pem;  ssl_certificate_key /etc/letsencrypt/live/wiki.mydomain.com/privkey.pem;  ssl_session_timeout 5m;  ssl_ciphers \u0026#39;AES128+EECDH:AES128+EDH:!aNULL\u0026#39;;  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  ssl_prefer_server_ciphers on;   location / {  try_files $uri $uri/ @dokuwiki;  }   location @dokuwiki {  rewrite ^/_media/(.*) /lib/exe/fetch.php?media=$1 last;  rewrite ^/_detail/(.*) /lib/exe/detail.php?media=$1 last;  rewrite ^/_export/([^/]+)/(.*) /doku.php?do=export_$1\u0026amp;id=$2 last;  rewrite ^/(.*) /doku.php?id=$1 last;  }   location ~ /(data|conf|bin|inc)/ {  deny all;  }   location ~* \\.(css|js|gif|jpe?g|png)$ {  expires 1M;  add_header Pragma public;  add_header Cache-Control \u0026#34;public, must-revalidate, proxy-revalidate\u0026#34;;  }   location ~ \\.php$ {  fastcgi_split_path_info ^(.+\\.php)(/.+)$;  fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock;  fastcgi_index index.php;  include fastcgi_params;  fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;  fastcgi_intercept_errors off;  fastcgi_buffer_size 16k;  fastcgi_buffers 4 16k;  }   location ~ /\\.ht {  deny all;  } }  server {  listen 80;  server_name wiki.mydomain.com;  add_header Strict-Transport-Security max-age=2592000;  rewrite ^ https://wiki.mydomain.com$request_uri? permanent; } 注：要记得修改配置中的证书和密钥的路径\nphp-fpm #  将配置文件/etc/php-fpm.d/www.conf中的下列项修改一致\nuser = nginx group = nginx listen = /var/run/php-fpm/php-fpm.sock listen.owner = nginx listen.group = nginx listen.mode = 0660  注：listen的配置要与 nginx 配置中的 fastcgi_pass unix 一致\n启动 #  执行下面命令启动 php-fpm、nginx 服务\nsystemctl start php-fpm nginx systemctl enable php-fpm  注：要记得配置防火墙开放对应的端口或者关闭防火墙\n部署脚本 #  详见 dokuwiki_deploy#dokuwiki_deploy.sh\n备份 #  dokuwiki 的备份比较简单，可以只备份以下目录即可\n * data/pages -包含您当前的页面\n* data/meta -包含有关您的页面的元信息（例如最初创建者，订阅者等等）\n* data/media -包含您当前的媒体（图像，PDF等）\n* data/media_meta -媒体的元数据\n* data/attic -页面的所有旧版本\n* data/media_attic -媒体的所有旧版本\n* conf -配置设置\n 以上出自官网的 备份教程。\n参考资料 #   使用 Nginx 的 DokuWiki - 官网\n"},{"id":3,"href":"/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","title":"常见问题","section":"Dokuwiki","content":"禁止您无权访问此服务器上的/dokuwiki #  权限问题，检查以下两点\n 注意下dokuwiki下文件的权限（nginx的执行用户是nginx） dokuwiki.conf的中指定的路径是否正确  because search permissions are missing on a component of the path #  关闭 SELinux 即可，关闭命令\nsetenforce 0  访问网页返回 502 bad gateway #  nginx 找不到 php 了，检查下 nginx 对应的服务的配置中的 fastcgi_pass unix 项和 php 的 www.conf 配置文件中的 listen 的值是否一致\n中文文件名乱码 #  在网页创建的中文名字空间和页面后，在服务器上全都显示的都是乱码 在文件 conf/local.php 最后添加\n$conf['fnencode'] = 'utf-8';  修改 inc/pageutils.php\nfunction utf8_encodeFN($file,$safe=true){ global $conf; if($conf['fnencode'] == 'utf-8') return $file; if($safe \u0026amp;\u0026amp; preg_match('#^[a-zA-Z0-9/_\\-\\.%]+$#',$file)){ return $file; } if($conf['fnencode'] == 'safe'){ return SafeFN::encode($file); } // 注释掉下面两行 // $file = urlencode($file); // $file = str_replace('%2F','/',$file); return $file; } function utf8_decodeFN($file){ global $conf; if($conf['fnencode'] == 'utf-8') return $file; if($conf['fnencode'] == 'safe'){ return SafeFN::decode($file); } // 注释掉下面一行 // return urldecode($file); // 加上下面这行 return $file; }  参考自： dokuwiki：解决中文乱码问题\nPHP 函数xml_parser_create不可用。也许您的托管服务提供商出于某种原因禁用了它 #  没有安装 xml 模块，搜索安装对应的模块即可\nyum install -y php-xml.x86_64  重定向的次数过多 #  因为给网站套上了 cdn，其中的 ssl 设置不正确，详细原因和解决方法请参考《 使用cloudflare后无限跳转》\n"},{"id":4,"href":"/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E6%8F%92%E4%BB%B6%E4%B8%8E%E4%B8%BB%E9%A2%98/indexmenu/","title":"Indexmenu","section":"插件与主题","content":"indexmenu #   indexmenu 可以插入完全可自定义的索引或从指定名称空间开始的页面列表。\n基本语法 #  {{indexmenu\u0026gt;ns[#n] [ns1[#n] ns2[#n] …] | [js[#theme]] [tsort] … }}  [] 内的是可选项\n常用的几种语句 #  从根名称空间显示 #  全部展开\n {{indexmenu\u0026gt;:}}  从当前名称空间 #  仅显示当前级别，不展开任何节点\n {{indexmenu\u0026gt;.#1}}  展开当前页面的父名称空间 #  显示父名称空间（“上行链路”）和当前级别，不展开任何节点\n {{indexmenu\u0026gt;..:#1}}  展开包含指定的名称空间 #  以展开包含 wiki 的名称空间为例，语法如下：\n {{indexmenu\u0026gt;:wiki#1|js}}  不显示指定的名字空间 #  以不显示 users 名字空间为例，语法如下：\n {{indexmenu\u0026gt;.:#1|js skipns=/^users$/}}  不显示指定页面 #  以不显示 start 和 sidebar 页面为例，语法如下：\n {{indexmenu\u0026gt;.:#1|js skipfile+/(^|:)(start|sidebar)$/}}  遇到的问题 #  Indexmenu id conflict #  这个问题是因为页面中有多个 Indexmenu 生成的索引。\n我遇见这个问题是因为我打开了 sidebar 页面，页面与侧边栏都渲染了一遍导致的，并不影响使用，关掉 sidebar 页面就行了。\n"},{"id":5,"href":"/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/dokuwiki/%E6%8F%92%E4%BB%B6%E4%B8%8E%E4%B8%BB%E9%A2%98/start/","title":"Start","section":"插件与主题","content":"当前使用的主题 #  Bootstrap3 #   文档\n当前使用的插件 #  Add New Page #   文档\n创建新的 wiki 页面\nmove #   文档\n移动页面和名字空间\nIndexMenu #   文档\n显示全局的索引。\nnspages #   文档\n显示页面列表。\nsmtp #   文档\n使用自定义的邮箱发送邮件。\nfastwiki #   文档\n提供快速编辑功能，能在页面中只修改一部分，不用渲染整个页面\nmathjax #   文档\n支持 mathjax 数学公式的语法，目前不怎么用数学公式，使用率低暂时先关闭了。\ndw2pdf #   文档\n提供 pdf 下载的功能，在个人知识库中没有使用这个功能。\nvshare #   文档\n可以嵌入来自其他视频网站的视频。\n"},{"id":6,"href":"/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/mediasoup/mediasoup%E7%9A%84%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/","title":"Mediasoup的安装部署","section":"Mediasoup","content":"Mediasoup 的安装与部署 #  环境要求 #  官方要求：\n cmake \u0026gt;= 3.5 gcc 和 g++ \u0026gt;= 4.9 或 clang（具有C++ 11支持） node.js \u0026gt;= 10.0, npm \u0026gt;= 6.3  使用 cmake --version 检查是否需要[安装或升级](/工具/编程工具/编译工具/cmake/介绍与安装#CMake 的安装) CMake，gcc --version 检查是否需要[升级 GCC](/操作系统/linux/升级gcc#编译 GCC), nodejs -v 检查是否需要[[|安装或升级]] Nodejs\n除了上述的环境还需要 编译安装部署#安装 python\n安装 #  下载 #  需要下载 mediasoup v3 mediasoup v3 demo github，在 github 上下载就可以\n安装 mediasoup-demo #  cd mediasoup-demo/server npm install cd ../app npm install  注意： 如果 npm 速度过慢或者超时，可以将源修改为淘宝的源或者[[|使用 cnpm]]\n配置 server #  cd server cp config.example.js config.js  因为新版本demo没有生成了证书，所以需要 自行生成证书并且放置相对应的目录(以 server 目录为根的相对路径，如果想使用绝对路径则需要将配置项中的 ${__ dirname} 删掉).\n修改 config.js 文件 #   ... tls : { //需要生成一个证书秘钥，这个用命令自行生成，并放置相对应的目录 cert : process.env.HTTPS_CERT_FULLCHAIN || `${__dirname}/certs/xxx_server.crt`, key : process.env.HTTPS_CERT_PRIVKEY || `${__dirname}/certs/xxx_server.key` } }, ... webRtcTransportOptions : { listenIps : [ { ip : process.env.MEDIASOUP_LISTEN_IP || '192.168.137.139', //修改为服务端的IP地址，如果是公网则为外网 IP announcedIp : process.env.MEDIASOUP_ANNOUNCED_IP } ], ... plainRtpTransportOptions : { listenIp : { ip : process.env.MEDIASOUP_LISTEN_IP || '1.2.3.4', announcedIp : process.env.MEDIASOUP_ANNOUNCED_IP }, maxSctpMessageSize : 262144 } } };  注意事项：\n 确保将 https.listenIp 设置为 0.0.0.0; 确保 TLS 证书位于 server/certs 名称为 fullchain.pem 和的目录中 privkey.pem; 默认的 mediasoup 端口范围是 2000-2020，不适合生产。应该使用更高的端口，但是然后应该在 network=\u0026quot;host\u0026quot;模式下运行容器;  启动服务 #  cd server DEBUG=\u0026quot;*mediasoup* *ERROR* *WARN*\u0026quot; INTERACTIVE=\u0026quot;true\u0026quot; node server.js  启动客户端 #  cd app npm start  在浏览器打开 #  访问 https://192.168.11.18:3000/?info=true\n注意：\n 防火墙是否关闭或允许访问 3000 端口;  URL中的 /?info=true 一定要带;    邀请参会 #  在 web 页面的上方中间，有一个 INVITAIONLINK 的按钮，点击后会复制邀请链接，当通过这个邀请链接进入 web 页面时就会进行参考。\n遇见的问题 #  OSError: [Errno 2] No such file or directory #  这是 python 报的错误，怀疑是 python 使用的 gcc 编译器版本不对导致（因为 gcc 已经升级成了 8.4.0，但是 python 显示的 gcc 编译器还是 4.8.5），在本机用 8.4.0 重新编译一下 python 试试。\n结果：编译 python2.7 解决的，python3 没有成功，原因不详。\nRuntimeError: gcc \u0026lt;= 4.8 not supported, please upgrade your gcc #  这是因为手动编译的 gcc 安装时软连接没有修改好，运行 cc --version 检查一下就会发现输出的版本号依旧是老版本，重新建立下软链接即可。\nln -sf /usr/local/bin/gcc /usr/bin/cc  参考自： 升级的GCC，仍然出现错误：gcc \u0026lt;= 4.8不支持，请升级您的gcc\nserver 代码 npm install 超时，导致 install 失败 #  cd node_modules rm -rf clang-tools-prebuilt rm -rf mediasoup npm install  参考资料 #   【流媒体服务器Mediasoup】环境部署与demo搭建(二)\n"},{"id":7,"href":"/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/nginx/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/","title":"安装与部署","section":"Nginx","content":"======= Nginx 安装与部署 =======\n命令安装 #  先安装\nsudo yum install -y yum-utils  设置 yum 存储库，创建/etc/yum.repos.d/nginx.repo文件输入以下内容：\n[nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/\\$releasever/\\$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/\\$releasever/\\$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true  默认情况下，使用的是稳定版的 nginx 软件包存储库，如需要使用主线版本，则执行下面命令：\nsudo yum-config-manager --enable nginx-mainline  然后再执行安装命令\nsudo yum -y install nginx  综合以上命令\nsudo yum install -y yum-utils cat\u0026gt;\u0026#34;/etc/yum.repos.d/nginx.repo\u0026#34;\u0026lt;\u0026lt;EOF [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/\\$releasever/\\$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/\\$releasever/\\$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true EOF sudo yum -y install nginx "},{"id":8,"href":"/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/nginx/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/","title":"常用配置","section":"Nginx","content":"Nginx 的常用配置 #  Post 返回静态内容 #  因为 Nginx 有着无法根据 POST 请求提供静态内容的限制，所以可以利用这个限制将 405 错误信息替换成静态内容来达到目的。主要配置\nerror_page 405 =200 $uri  参考资料 #   POST 请求出现 405（不允许）\n不允许 POST 请求 - 405 Not Allowed - nginx，即使包含标头\nServing Static Content Via POST From Nginx\n接收 Post 请求参数 #  在文件 nginx.conf 中 http 的配置里添加下面的内容\nhttp{ ... log_format post_tracking '$remote_addr - $remote_user [$time_local] \u0026quot;$request\u0026quot; ' '$status $body_bytes_sent \u0026quot;$http_referer\u0026quot; ' '\u0026quot;$http_user_agent\u0026quot; \u0026quot;$http_x_forwarded_for\u0026quot; \u0026quot;$request_body\u0026quot; '; ... } \n参考资料 #   nginx 配置接收 post 请求参数\n"},{"id":9,"href":"/%E5%B7%A5%E5%85%B7/%E6%9C%8D%E5%8A%A1/prometheus/%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/","title":"部署与使用","section":"Prometheus","content":"Prometheus 的部署与使用 #  "},{"id":10,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ci_cd/jenkins/jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/","title":"Jenkins的安装与部署","section":"Jenkins","content":"Jenkins 的安装与部署 #  准备 #  硬件要求 #  最低硬件要求\n 256 MB 内存; 1 GB 的驱动器空间（尽管如果将 Jenkins 作为 Docker 容器运行，建议至少使用 10 GB）;  小团队推荐的硬件配置：\n 4 GB+ 的内存; 50 GB+ 的驱动器空间;  更多要求请参考官方的 硬件推荐\n软件要求 #  Java #   32 位和 64 位版本均支持 Java 8 运行时环境 支持 Java 11 运行时环境  Java 11 Docker 安装说明包含在“在 Docker 中下载和运行 Jenkins”中 有关其他升级说明，请参阅Java 8 到 Java 11 升级指南   不支持 Java 7 及之前版本 不支持 Java 9 和 10 不支持 Java 12、13、14、15 和 16  这些要求适用于 Jenkins 系统的所有组件，包括 Jenkins 控制器、所有类型的代理、CLI 客户端和其他组件。\n安装 #  Centos #  安装命令:\nsudo wget -O /etc/yum.repos.d/jenkins.repo \\  https://pkg.jenkins.io/redhat-stable/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key sudo yum upgrade sudo yum install epel-release java-11-openjdk-devel sudo yum install jenkins sudo systemctl daemon-reload sudo systemctl start jenkins Windows #  在 下载 Jenkins 的页面下载对应的 msi 安装包，根据提示安装即可。\n设置向导 #  解锁 Jenkins #  当第一次访问一个新的 Jenkins 实例时，需要使用系统自动生成的密码来解锁\n 访问 http://localhost:8080 (端口默认是 `8080`，如果有修改则替换成修改的端口，要记得在防火墙添加对应的端口);  自动生成的密码在 /var/lib/jenkins/secrets/ （Windows 在 C:\\Program Files\\Jenkins\\secrets\\，如果自定义安装路径则在安装的路径中）路径下的 initialAdminPassword 文件中;  使用插件自定义 Jenkins #  建议选择 Install suggested plugins(建议安装的插件)\n配置主从节点 #  Jenkins master 附带 Jenkins 的基本安装，在此配置中，master 处理构建系统的所有任务并分配从节点并将构建发送给从节点以执行作业。\n设置 Centos 从节点 #   添加新节点(Manage Jenkins -\u0026gt; Manage Nodes and Clouds -\u0026gt;新建节点);   输入节点名称，勾选 Permanent Agent;\n 建议设置 描述 和 标签 方便管理; 在 远程工作目录 设置从节点机器上 Jenkins 的专用目录;\n 启动方式选择 Launch agents via SSH，主机 中输入从节点的 ip，Credentials 选择对应的凭证(如果没有可以点击旁边的 添加 选择 Jenkins);\n 添加凭证;\n 保存  设置 Windows 从节点 #  前半部分与 [设置 Centos 从节点](##设置 Centos 从节点) 一致，从第 5 步开始不同。\n 启动方式选择 Launch agent by connecting it the master(如果没有这项则需要修改 Configure Global Security)，勾选 Use WebSocket;\n 修改 Manage Jenkins -\u0026gt; Configure Global Security -\u0026gt; 代理;\n 保存，返回节点列表;\n 点击刚刚添加的节点会弹出下面的页面，点击其中的 agent 下载文件 agent.jar;\n 把刚下载的文件放到从节点机器上，并执行页面中的命令(注：需要 java 环境，要提前装好，版本最好与主节点上的一致+);  参考资料 #   官网 - 安装 Jenkins\nJenkins 配置主从节点\njenkins 配置windows节点实现自动化部署\n"},{"id":11,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ci_cd/jenkins/jenkins%E9%85%8D%E7%BD%AEsvn%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/","title":"Jenkins配置svn持续集成环境","section":"Jenkins","content":"Jenkins 配置 SVN 持续集成环境 #  准备 #  安装 Jenkins 插件 Subversion\n配置 #   将 SVN 的用户名和密码添加到 凭证中; 创建一个新的任务;  勾选 General 中的 限制项目的运行节点 并指定节点(无需要可以跳过这步); 源码管理 中勾选 Subversion，在 Repository URL 中添加仓库的地址，Credentials 选择第 1 步中配置的凭证;\n 勾选 构建触发器 中的 Build periodically(控制任务的构建周期) 和 Poll SCM(检查 SVN 是否有新的提交的周期)，下图示例是每 30 分钟构建一次任务，5 分钟检查一次 SVN 是否更新;\n 勾选 构建环境 中的 Delete workspace before build starts(无需要可以跳过这步); 构建 -\u0026gt; 增加构建步骤 中选择准备使用的方式(一般 Linux 环境使用 Execute shell，Windows 使用 Execute Windows batch command);    扩展 #  windows 构建方法 #  在 Windows 下 Jenkins 自带的构建步骤是使用 Windows 批处理脚本，想要编译 VS 的工程会比较麻烦，在这里推荐使用插件 MSBuild。\n配置 MSBuild #   安装插件 MSBuild; 安装完成后在 `Global Tool Configuration -\u0026gt; MSBuild -\u0026gt; 新增 MSBuild` 中添加 MSBuild.exe 的路径(默认在C:\\\\WINDOWS\\\\Microsoft.NET\\\\Framework\\\\\\[version\\]. 下，如果不是默认目录自行搜索)并保存;\n 创建任务，任务的配置与 #配置中创建的步骤基本一致，不同的地方在于最后一步 构建 选择的是 Build a Visiual Studio project or solution using MSBuild; MSBuild Version MSBuild Build File: .sln 或 .proj 的路径(不知道他的起始路径是哪里，这里就直接填的绝对路径);  Command Line Arguments: MSBuild 的命令行参数，这里提供两个实用的参数，详细的请参考参考资料; -t:project_name: 生成 project_name 项目; -p:Platform=x64: 生成 x64 版本; -p:Configuration=Release: 生成 Release 版本;    参考资料 #   【手把手】10分钟搭建Jenkins+SVN持续集成环境\njenkins_windows(七)：SVN自动触发项目构建的配置\nJenkins 配置svn自动部署\n命令行上的 MSBuild - C++\nMSBuild 命令行参考\n使用msbuild指定解决方案的项目文件\n"},{"id":12,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ide/visual_studio/cpp%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E4%BB%8B%E7%BB%8D/","title":"Cpp项目中的一些配置介绍","section":"Visual Studio","content":"Visual Studio 的 C++ 项目中的一些配置的介绍 #  VC++包含目录和 C++ 附加包含目录的区别 #  c/c++ 附加包含目录，代表的是c/c++文件编译时所需要的头文件，而资源编译时也是需要附加包含库目录的，而 vc++ 的包含目录，代表的是全局项目的包含目录。配置过VC++里面的库，C/C++里面的就可以不用配置。\n参考资料 #   VC包含目录和c/c 附加包含目录的区别\n默认的属性文件 #  vs2017 #   Microsoft.Cpp.x64.user 系统默认的属性表，全路径为 C:\\Users\\horswing\\AppData\\Local\\Microsoft\\MSBuild\\v4.0\\Microsoft.Cpp.x64.user.props 项目创建后，默认有这个属性表。双击可以修改（效果与 solution explorer 项目名上右键 -\u0026gt; property 一致），右键选则 remove 和移除。  Application 表示这个项目生成的是一个“应用程序”（不是DLL或LIB）。在 Property Manger 里，这项是不能改的，所以你发现双击后，出现的页面是灰色的，右键也只有 property 选项。 在哪里改呢？\n在 solution explorer 里的 项目属性 -\u0026gt; gerneral -\u0026gt; Project Defaults -\u0026gt; Configuration Type. Unicode Support 和 Core Windows Libraries 和 Application 项一样，这两项也是“只能看不能改的”，要改分别在 项目属性 -\u0026gt; gerneral -\u0026gt; Project Defaults 里的 Character Set 和 Use of MFC 修改。    vs2019 #   vs2019 相较于 vs2017 少了 Microsoft.Cpp.x64.user 多了 whole program optimization  参考资料 #   visual studio属性管理器（property manager）上各项的含义\n多张属性表叠加 #  多张属性表一起使用时，两张表定义了相同的属性，后面的表的配置优先。\n例如，当两张表同时定义了 \u0026ldquo;附加包含目录\u0026rdquo;，在没有选择继承的情况下，则只有后面导入的属性表的该项配置生效，如果选择了继承则同时生效（因为后一张属性表将前一张属性表的该项配置继承了，本质上还是后一张属性表的配置生效）\n\u0026gt; Property sheets are a nice way to set up properties to projects. Each property sheet is a collection of properties for a project. One can attach arbitrarily many property sheets to each project, and the property sheets can be shared between projects. The latter feature is the essential one. \u0026gt;\n In my solutions at least, the projects share very similar properties. Now I can create just one property sheet for the whole solution and apply that to each project. If I want to change the properties, I will do so in the property sheet.\n \u0026gt;\n What’s more, multiple property sheets can be layered so that the union of their properties applies. The sheets are given an order. If two sheets define the same property, then the later one takes priority.\n \u0026gt;\n The strategy is to give each solution a property sheet in which to configure output directories, disable warnings, and disable secure-stl etc. You will then make this property sheet part of your solution, in the sense of carrying it around in the version control.\n \u0026gt;\n There are also special global property sheets called Microsoft.Cpp.Win32.user and Microsoft.Cpp.Win64.user which are automatically added to each configuration of each project. These will apply properties globally on your computer. If you change to another computer, these settings are lost. These property sheets are ideal for specifying include and library directories for external libraries (which are of course computer-specific). While the former works on 32-bit builds, the latter works on 64-bit builds. Of course, you will want to choose different directories for them.\n \u0026gt;\n A bit odd feature of the property sheets is that they won’t get save automatically when you change a property. You must either Save All, or right click on the property sheet and save it. This is unintuitive and causes unnecessary confusion from time to time.\n \u0026gt;\n It is useful to notice that a property sheet can be added to all projects and configuration at the same time. Simply select the desired projects or configurations and right click to add an existing property sheet. Unfortunately, it seems a given property sheet can not be removed from all projects at once.\n \u0026gt;\n If you need to set project-specific properties, do note that you must explicitly bring in the inherited properties. For example, in the Preprocessor definitions property, this is done by %(PreprocessorDefinitions).\n \u0026gt;\n There is a trap in the command-line settings. If you specify Additional Options in a project, then those will not be unioned with the additional options in the property sheets. Unless I am mistaken, it is missing a way to bring in the inherited options. Therefore, you should use the other options explicitly instead. For example, if you need a preprocessor definition, do it in the Preprocessor definitions property instead of as a /D switch in Additional Options.\n 参考资料 #   Property sheets in Visual Studio 2010\n"},{"id":13,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ide/visual_studio/visual_studio%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/","title":"Visual Studio的一些实用功能","section":"Visual Studio","content":"Visual Studio 的一些实用功能 #  代码编辑 #  代码格式化 #  Visual Studio 2017 15.7 Preview 1 为 C++ 开发人员提供了内置的 ClangFormat 支持。内置 LLVM、Google、Chromium、Mozilla 或 WebKit 等格式约定。\n=== 使用方式 === 快捷键：Ctrl+k Ctrl+d\n菜单选项：编辑 -\u0026gt; 格式文档\n选择格式 #  工具 -\u0026gt; 选项 -\u0026gt; 文本编辑器 -\u0026gt; C/C++ -\u0026gt; 代码样式 -\u0026gt; 格式设置 -\u0026gt; 默认格式设置样式\n参考资料 #   Visual Studio 2017 中的 ClangFormat 支持\nVisual Studio和VS Code使用clang-format自定义C++代码默认格式化样式\n"},{"id":14,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ide/vscode/%E6%8F%92%E4%BB%B6remote_ssh%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"插件remote Ssh的使用","section":"VSCode","content":"插件 Remote-SSH 的使用 #  安装 #  在 vscode 的扩展里搜索 Remote-SSH\n点击安装，等待安装完成即可，安装完成后会在左侧的侧边栏多出一个图标。\n配置 #    按顺序点击图中 1、2 的图标; 在图中 3 的位置输出要远程连接的机器的用户名和地址，例如：ssh root@192.168.13.97; 输入完成后回车，点击 C:\\User\\xxx\\.ssh\\config 就可以看到连接已添加进来了，如果没有点击图中 4 的位置刷新;\n 在已添加的连接上右键，选择 Connect to Host in New Windows;\n 选择目标机器的系统类型（当无法识别目标机器的系统时会弹出该选项）;\n 选择 Connect; 输入密码;\n 输完密码后右下角有提示在下载安装 VS Code Server，等待其完成即可;\n 左下角这里类似这样的显示就是连接完成了;\n  参考资料 #   使用 SSH 进行远程开发\n玩转VSCode插件之Remote-SSH\nVSCode:Remote-SSH配置实录\n"},{"id":15,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/ide/vscode/%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/","title":"设置用户代码片段","section":"VSCode","content":"设置用户代码片段 #  设置方式 #  以 Markdown 为例\n 文件 \u0026gt; 首选项 \u0026gt; 用户代码片段 输入 markdown，编辑 markdown.json:\n{ // Place your snippets for markdown here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the // same ids are connected. // Example: // \u0026quot;Print to console\u0026quot;: { // \u0026quot;prefix\u0026quot;: \u0026quot;log\u0026quot;, // \u0026quot;body\u0026quot;: [ // \u0026quot;console.log('$1');\u0026quot;, // \u0026quot;$2\u0026quot; // ], // \u0026quot;description\u0026quot;: \u0026quot;Log output to console\u0026quot; // } \u0026quot;blog-header\u0026quot;: { //\u0026quot;scope\u0026quot;: \u0026quot;markdown\u0026quot;, \u0026quot;prefix\u0026quot;: \u0026quot;blog-header\u0026quot;, \u0026quot;body\u0026quot;: [ \u0026quot;+++ \u0026quot;, \u0026quot;author = \\\u0026quot;\\\u0026quot; \u0026quot;, \u0026quot;title = \\\u0026quot;\\\u0026quot; \u0026quot;, \u0026quot;date = \\\u0026quot;\\\u0026quot; \u0026quot;, \u0026quot;description = \\\u0026quot;\\\u0026quot; \u0026quot;, \u0026quot;tags = [\\\u0026quot;\\\u0026quot;] \u0026quot;, \u0026quot;categories = [\\\u0026quot;\\\u0026quot;]\u0026quot;, \u0026quot;url = \\\u0026quot;/blog/ \u0026quot;, \u0026quot;[[images]] \u0026quot;, \u0026quot;src = \\\u0026quot;/img/ \u0026quot;, \u0026quot;alt = \\\u0026quot;\\\u0026quot; \u0026quot;, \u0026quot;stretch = \\\u0026quot;stretchH\\\u0026quot; \u0026quot;, \u0026quot;+++ \u0026quot; ], \u0026quot;description\u0026quot;: \u0026quot;博客文件的头，内置标签、分类、标题等信息\u0026quot; } }    文件 \u0026gt; 首选项 \u0026gt; 设置，设置窗口打开后点击左侧的**文本编辑器(Text Editor)菜单，在右侧出现的设置界面中下滑，找到并点击(Edit in settings.json)**即可打开 settings.json，在其中添加下面的代码:\n\u0026quot;[markdown]\u0026quot;: { \u0026quot;editor.quickSuggestions\u0026quot;: true }  保存好了以后重启一下 VSCode.  "},{"id":16,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","title":"创建远程仓库","section":"Git","content":"Git 创建远程仓库 #  本地远程仓库 #  创建目录 #  在本地要当做远程仓库的路径创建一个空目录（与你要本地仓库同名）并创建裸仓库\nmkdir ~/Temp/git_server/Test/ git init--bare 关联仓库 #  本地仓库关联远程仓库\ngit remote add origin ~/Temp/git_server/Test/ 如果远程地址设置错了，可以使用以下命令重置\ngit remote set-url origin ~/Temp/git_server/NewTest/ 提交 #  提交到远程仓库\ngit push -u origin master #!/bin/sh # # An example hook script to prepare a packed repository for use over # dumb transports. # # To enable this hook, rename this file to \"post-update\". #exec git update-server-info # 添加以下三行即可 unset GIT_DIR cd .. git checkout -f  -- "},{"id":17,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"常用命令","section":"Git","content":"Git 的常用命令 #  基础命令 #  本地 #  创建存储库 #  git init repositories_name 状态查看 #  git status 文件操作 #  # 添加文件 git add filename  # 删除文件 git rm filename  # 移动或重命名 git mv filename_src filename_dst 提交文件 #  git commit -m \u0026#34;提交内容的描述\u0026#34; 比较差异 #  git diff filename 查看提交记录 #  git log  # 简版记录 git log --pretty=oneline 版本回退 #  # 回退到上个版本 git reset --hard HEAD^  # 回退到上上个版本 git reset --hard HEAD^^  # 回退到上100个版本 git reset --hard HEAD~100  # 回退到指定版本 git reset --hard commit_id 查看执行命令的记录 #  git reflog "},{"id":18,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/","title":"编译安装","section":"Git","content":"git 编译安装 #  准备 #  安装依赖 #  yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel yum install -y gcc perl-ExtUtils-MakeMaker 下载源码 #  git clone https://github.com/git/git.git 注：如果没有给 git 配置代理的话，建议直接下载压缩包会更快些。\n编译 #  编译命令 #  make prefix=/usr/local/git all make prefix=/usr/local/git install 这里提醒下，如果 git 的源码是从 windows 下拷过来的要注意下文件的可执行权限\n创建软连接 #  ln -s /usr/local/git/bin/git /usr/bin/git "},{"id":19,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E8%A1%8D%E7%94%9F%E5%93%81/gitea/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/","title":"安装与部署","section":"Gitea","content":"Gitea 安装与部署 #  准备 #  下载文件 #  从官网的 下载页面中选择与目标平台匹配的文件，复制 URL 并替换以下命令中的 URL：\nwget -O gitea https://dl.gitea.io/gitea/1.14.5/gitea-1.14.5-linux-amd64 shell chmod +x gitea 环境准备 #  确保已安装 Git #  git --version 创建运行 Gitea 的用户 #  adduser \\  git \\  --system \\  --shell /bin/bash \\  --home /home/git 创建所需的目录结构 #  mkdir -p /var/lib/gitea/{custom,data,log} chown -R git:git /var/lib/gitea/ chmod -R 750 /var/lib/gitea/ mkdir /etc/gitea chown root:git /etc/gitea chmod 770 /etc/gitea 注意： /etc/gitea是具有用户写权限的临时设置，git以便Web安装程序可以写配置文件。安装完成后，建议使用以下命令将权限设置为只读：\nchmod 750 /etc/gitea chmod 640 /etc/gitea/app.ini 移动 Gitea 二进制文件 #   chown git:git gitea  mv gitea /usr/local/bin/gitea 安装 #  运行 #  执行命令\nGITEA_WORK_DIR=/var/lib/gitea/ /usr/local/bin/gitea web -c /etc/gitea/app.ini 使用参数 -p 可指定自定义端口运行 Gitea\n网页安装 #  Gitea 启动后在浏览器中输入对应的 URL，例如：192.168.1.1:3000 即可出现安装的页面\n这些设置没什么特别难懂的地方，根据提示填写自己的设置保存并安装即可。等安装完成后会自动跳转到用户页面\n考虑到安全问题，需要修改 /etc/gitea 的权限\nchmod 750 /etc/gitea chmod 640 /etc/gitea/app.ini 设置系统服务 #  将下面的内容复制到 /etc/systemd/system/gitea.service，然后将要使用的服务放开注释，例如 MySQL。\n[Unit] Description=Gitea (Git with a cup of tea) After=syslog.target After=network.target ### # Don\u0026#39;t forget to add the database service dependencies ### # #Wants=mysql.service #After=mysql.service # #Wants=mariadb.service #After=mariadb.service # #Wants=postgresql.service #After=postgresql.service # #Wants=memcached.service #After=memcached.service # #Wants=redis.service #After=redis.service # ### # If using socket activation for main http/s ### # #After=gitea.main.socket #Requires=gitea.main.socket # ### # (You can also provide gitea an http fallback and/or ssh socket too) # # An example of /etc/systemd/system/gitea.main.socket ### ## ## [Unit] ## Description=Gitea Web Socket ## PartOf=gitea.service ## ## [Socket] ## Service=gitea.service ## ListenStream=\u0026lt;some_port\u0026gt; ## NoDelay=true ## ## [Install] ## WantedBy=sockets.target ## ### [Service] # Modify these two values and uncomment them if you have # repos with lots of files and get an HTTP error 500 because # of that ### #LimitMEMLOCK=infinity #LimitNOFILE=65535 RestartSec=2s Type=simple User=git Group=git WorkingDirectory=/var/lib/gitea/ # If using Unix socket: tells systemd to create the /run/gitea folder, which will contain the gitea.sock file # (manually creating /run/gitea doesn\u0026#39;t work, because it would not persist across reboots) #RuntimeDirectory=gitea ExecStart=/usr/local/bin/gitea web --config /etc/gitea/app.ini Restart=always Environment=USER=git HOME=/home/git GITEA_WORK_DIR=/var/lib/gitea # If you install Git to directory prefix other than default PATH (which happens # for example if you install other versions of Git side-to-side with # distribution version), uncomment below line and add that prefix to PATH # Don\u0026#39;t forget to place git-lfs binary on the PATH below if you want to enable # Git LFS support #Environment=PATH=/path/to/git/bin:/bin:/sbin:/usr/bin:/usr/sbin # If you want to bind Gitea to a port below 1024, uncomment # the two values below, or use socket activation to pass Gitea its ports as above ### #CapabilityBoundingSet=CAP_NET_BIND_SERVICE #AmbientCapabilities=CAP_NET_BIND_SERVICE ### [Install] WantedBy=multi-user.target 部署脚本 #  详见 gitea_deploy#gitea_deploy.sh\n扩展 #  启用 SSH 支持 #  禁止 git 用户进行 ssh 登录，但还能使用 ssh url 克隆存储库 A\n解决方法 #  1. 配置 /etc/gitea/app.ini 中的 SSH_DOMAIN，例如\nSSH_DOMAIN = git.domain.tld 2. 配置 ssh 默认情况下，Gitea 将以 user git 身份运行，并且此帐户将用于 ssh 存储库访问。要使用 ssh 访问，必须启用 PAM。\n修改文件 /etc/ssh/sshd_config\n... UsePAM yes ... 重启 ssh 服务\n参考自 https://wiki.archlinux.org/title/Gitea#Enable_SSH_Support#Enable SSH Support\n参考资料 #   install-from-binary\nRun Gitea as Linux service\n"},{"id":20,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E8%A1%8D%E7%94%9F%E5%93%81/github/%E6%96%B0%E7%94%A8%E6%B3%95/","title":"新用法","section":"Github","content":"Github 的各种新用法 #  作为图床 #  本 Wiki 就是使用的 github 作为图床。\n操作步骤 #   在 github 创建一个仓库，一定要创建公开的仓库，如果是私有的会访问不了。 克隆该仓库到本地，添加一张图片，提交后推送到 github。 在仓库中找到刚刚推送的图片进入预览。 点击下载，会跳转到一个页面，这个页面就是这张图片的外链地址，这个地址就可以在其他地方访问了。 还有一种方法，在预览页面的地址后面加上 ?raw=true 后缀  "},{"id":21,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/","title":"配置代理","section":"Git","content":"在 \u0026ldquo;科学上网\u0026rdquo; 后使用 git 克隆 github 上的项目速度还是很慢。后来发现 git clone 时并没有走 \u0026ldquo;科学上网\u0026rdquo; 的代理，需要在 git 中设置一下代理才会使用。\n设置方法 #   查看 \u0026ldquo;科学上网\u0026rdquo; 开放的端口号与协议是什么，我的端口是 1080，协议是 socks。 打开 git bash   只代理 github  git config --global http.https://github.com.proxy socks://127.0.0.1:1080 git config --global https.https://github.com.proxy socks://127.0.0.1:1080  全局代理  git config --global http.proxy socks://127.0.0.1:1080 git config --global https.proxy socks://127.0.0.1:1080 注：\n 如果 \u0026ldquo;科学上网\u0026rdquo; 使用的协议是 https，则需要将命令中参数  socks://127.0.0.1:1080 替换成  https://127.0.0.1:1080 socks5 与上同理  取消代理 #   取消 github 的代理   git config --global --unset http.https://github.com.proxy  git config --global --unset https.https://github.com.proxy  取消全局代理  git config --global --unset http.proxy git config --global --unset https.proxy 查看当前设置的代理 #  git config --global --get http.proxy git config --global --get https.proxy 参考资料 #   知乎 - git clone一个github上的仓库，太慢，经常连接失败，但是github官网流畅访问，为什么？@汪小九\n"},{"id":22,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/svn/%E5%BF%BD%E7%95%A5%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95/","title":"忽略指定的文件或目录","section":"Svn","content":"SVN 忽略指定的文件或目录 #  和 Git 中的 .gitignore 的功能基本一致。\n设置方法 #   在项目下创建一个名为 .svnignore 的文件（svn 对这个没有要求，文件名可任意起，但是为了看起来规范所以叫这个）;  在文件 .svnignore 中添加要忽略的文件或目录，语法与 .gitignore 基本一致，目前发现有以下不同点; svn忽略的文件夹名称后面可以不用斜杠. svn忽略的文件列表，换行符不能是Windows的换行符(\\r\\n)，必须是 Unix 换行符(\\n)，可以使用编辑软件替换掉(例如：Notepad++). 在 svn 跟踪的项目目录下点击右键 -\u0026gt; TortoiseSVN -\u0026gt; Properties 会弹出窗口;\n 点击窗口右下角的 New... 选择 Other，在弹出的窗口中 Property name 选择 svn:global-ignores;\n 点击 Load... 选择刚刚准备好的 .svnignore 文件，点击 OK 即可。（不要选择 Apply property recursively 这一项）;\n    参考资料 #   【全网独家】SVN实现和Git .gitignore一样的全局忽略文件和文件夹\n"},{"id":23,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/cmake/%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/","title":"介绍与安装","section":"编译工具","content":"CMake 介绍与安装 #  CMake 介绍 #   CMake是一个跨平台的开源的元构建系统，可以构建，测试和打包软件。它可以用于支持多个本机构建环境，包括 make，Apple 的 xcode 和 Microsoft Visual Studio。\nCMake 的安装 #  Windows #  在官网 下载安装包安装即可。\nCentos #  安装 #  yum install -y cmake 安装完成后执行下面命令，检查是否成功。\ncmake -version 升级 #  有时候命令安装的版本不够，需要更高的版本，这时就需要手动进行升级。\n 卸载旧的 cmake yum remove -y cmake  在官网的下载页面找到需要的 cmake 版本，下载后并解压。我的命令如下: wget https://github.com/Kitware/CMake/releases/download/v3.20.0-rc2/cmake-3.20.0-rc2-linux-x86_64.tar.gz tar -zxvf cmake-3.20.0-rc2-linux-x86_64.tar.gz  将其复制到你要安装的目录。我安装的目录是 /usr/local/: cp cmake-3.20.0-rc2-linux-x86_64/* /usr/local/  在 \u0026lsquo;\u0026rsquo;/etc/profile \u0026rsquo;\u0026rsquo; 的最后一行添加你安装的目录，语法为 export PATH=$PATH:你安装的目录/bin。我安装的 /usr/local/ 目录是系统默认包含的，所以可以省略这步。 检查是否安装成功。  可能遇见的问题 #  CMake Error: Error executing cmake::LoadCache(). Aborting #  这个是我在手动安装 CMake 的时候没有把 share/cmake.*** 的文件也拷过去导致的，拷贝过去就可以了。\n"},{"id":24,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/cmake/%E7%94%9F%E6%88%90xcode%E5%B7%A5%E7%A8%8B/","title":"生成xcode工程","section":"编译工具","content":"生成 XCode 工程 #  方法 #  cmake 的构建命令增加参数 `-G \u0026ldquo;Xcode\u0026rdquo;`，例如\ncmake -G Xcode .. 遇到的问题 #  报错找不到编译器 #  错误信息 #  -- The C compiler identification is unknown  -- The CXX compiler identification is unknown  CMake Error at CMakeLists.txt:2 (project):   No CMAKE_C_COMPILER could be found.  CMake Error at CMakeLists.txt:2 (project):   No CMAKE_CXX_COMPILER could be found. 解决方法 #  执行命令下面的命令后再重试即可\n sudo xcode-select --switch /Applications/Xcode.app/ **注：**执行完命令后要清空 cmake 生成的缓存文件。\n参考资料 #   Mac cmake生成xcode项目工程\n"},{"id":25,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/adb%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Adb的使用","section":"调试工具","content":"adb 的使用 #  简介 #  Android 调试桥 (adb) 是一种功能多样的命令行工具，可让您与设备进行通信。adb 命令可用于执行各种设备操作（例如安装和调试应用），并提供对 Unix shell（可用来在设备上运行各种命令）的访问权限。它是一种客户端-服务器程序，包括以下三个组件：\n 客户端：用于发送命令。客户端在开发计算机上运行。您可以通过发出 adb 命令从命令行终端调用客户端。 守护程序(adbd)：用于在设备上运行命令。守护程序在每个设备上作为后台进程运行。 服务器：用于管理客户端与守护程序之间的通信。服务器在开发机器上作为后台进程运行。  adb 包含在 Android SDK 平台工具软件包中。您可以使用 SDK 管理器下载此软件包，该管理器会将其安装在 android_sdk/platform-tools/ 下。或者，如果您需要独立的 Android SDK 平台工具软件包，也可以点 击此处进行下载。\n如需了解如何连接设备以使用 ADB，包括如何使用 Connection Assistant 对常见问题进行排查，请参阅 在硬件设备上运行应用。\n使用 #  常用命令 #  adb connect 10.160.93.94 // 连接 adb disconnect // 断开连接 adb devices // 查看设备列表 adb shell 文件操作 #  从设备获取文件 #  adb pull /path_in_devices/src_file /local_dst_path 发送文件到设备 #  adb push /local_src_path/src_file /path_in_devices/dst_path/ 安装应用 #  应用程序安装-将一个包推送到设备上并安装它 #  adb install test.apk APP安装-将多个APK推送到一个包的设备上并安装它们 #  adb install-multiple test.apk test2.apk 应用程序安装-将一个或多个包推送到设备上，并以原子方式安装它们 #  adb install-multi-package test.apk demo.apk 替换现有应用程序，重新安装现有的应用程序，保存其数据 #  adb install -r test.apk 允许测试包 #  adb install -t test.apk 允许版本代码降级，仅可调试器包 #  adb install -d test.apk 授予所有运行时权限，授予应用程序清单中列出的所有权限 #  adb install -g test.apk 使应用程序作为临时安装应用程序安装 #  adb install --instant test.apk 使用快速部署 #  adb install --fastdeploy test.apk 始终按APK到设备和调用包管理器作为单独的步骤 #  adb install --no-streaming test.apk 参考资料 #   Android Studio - Android 调试桥(adb)\nadb 发送文件到Android设备和从Android手机复制文件\nadb安装apk\n"},{"id":26,"href":"/%E5%B7%A5%E5%85%B7/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/clang-tidy/","title":"Clang Tidy","section":"静态代码检测","content":"Clang-Tidy #  简介 #  clang-tidy 是一个基于 clang 的 C++ “linter” 工具。其目的是提供一个可扩展的框架，用于诊断和修复典型的编程错误，例如样式违规、接口滥用或可以通过静态分析推断出的错误。clang-tidy 是模块化的，并提供了一个方便的界面来编写新的检查。\n安装 #  Ubuntu #  sudo apt-get install clang-tidy-5.0 Centos #  sudo yum install -y centos-release-scl sudo yum install -y llvm-toolset-7 sudo yum install -y llvm-toolset-7-clang-analyzer llvm-toolset-7-clang-tools-extra 启动 #  scl enable llvm-toolset-7 \u0026#39;clang -v\u0026#39; scl enable llvm-toolset-7 \u0026#39;lldb -v\u0026#39; scl enable llvm-toolset-7 bash 使用 #  clang-tidy -list-checks -checks=\u0026#39;google\u0026#39; test.cpp --  -checks='google': 表示检测是否违反google code style; test.cpp: 被检测的文件; --: 表示这个文件不在compilation database里面，可以直接单独编译;  参考资料 #   clang-tidy\n深入研究Clang(十三)clang-tidy简介\nclang-tidy使用总结\n深入研究Clang(十四)clang-tidy的使用\n"},{"id":27,"href":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/centos7%E6%8C%82%E8%BD%BDwindows%E7%9A%84%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/","title":"Centos7挂载windows的共享目录","section":"Linux","content":"Centos7 挂载 windows 的共享目录 #  步骤 #  1. 在windows上创建一个共享目录 #  设置共享 #  右键需要共享的文件夹，点击“共享”，点击“共享此文件夹”，此时可以设置权限。默认权限是“读取”。\n更改权限 #  接着上述步骤，点击“权限”按钮，打开权限对话框，若需要写权限（修改权限），选中Everyone用户组，选中“修改”复选框或者“完全控制”复选框。点击“应用”“确定”。\n进入“安全”选项卡，选中Everyone用户组，选中“完全控制”，“应用”“确定”。 更改权限的两步必须同时设置才能生效。\n2. 在Centos7上挂载共享目录** 执行下面命令 #  mount -t cifs -o username=share,password=share //192.168.31.189/share /share 其中:\n username,password 是 windows 登录用户名密码 //192.168.31.189/share 就是windows要的共享文件夹 /share 是希望 Centos7 将共享文件夹要挂载到的地方，可任意定位置  3. 开机启动就挂载文件夹 #  在 /etc/fstab 文件中添加下列代码即可\n//192.168.31.189/share /share cifs username=share,password=share 0 0 遇到的问题 #  mount -t cifs -o username=share,password=share //192.168.31.189/share /share mount: //192.168.31.189/share 写保护，将以只读方式挂载 mount: 无法以只读方式挂载 //192.168.31.189/share 是因为缺少组件，安装后解决问题（具体是怎么查出来的我也不会😅，《 CentOS7挂载windows共享时提示写保护》中没有解释过程）\nyum install cifs-utils 参考 #   Windows共享文件夹权限设置\nCentOS7挂载Windows下的共享文件夹\nCentOS7挂载windows共享时提示写保护\n"},{"id":28,"href":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/firewalld%E7%9A%84%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE/","title":"Firewalld的规则配置","section":"Linux","content":"firewalld的规则配置 #  基本功能 #  查看防火墙 #  systemctl status firewalld 开启防火墙 #  systemctl start firewalld.service 重启防火墙 #  firewall-cmd --reload 端口管理 #  查看已开放的端口 #  firewall-cmd --zone=public --list-ports 添加端口到白名单 #  firewall-cmd --permanent --zone=public --add-port=8484/tcp  --zone 作用域 --add-port=8484/tcp 添加端口，格式为：端口/通讯协议 --permanent 永久生效，没有此参数重启后失效  从白名单移除端口 #  firewall-cmd --zone=public --remove-port=8484/tcp 服务管理 #  服务只是带有相关名称和描述的端口的简单集合。使用服务比端口更易于管理。\n获得可用服务的列表 #  firewall-cmd --get-services 查看当前已添加的服务 #  firewall-cmd --zone=public --list-services 添加服务 #  firewall-cmd --permanent --zone=public --add-service=ssh 自定义服务 #  服务的定义文件通常存放在下面的两个路径中：\n /usr/lib/firewalld/services/ /etc/firewalld/services/  其中第二个路径是存放非标准定义的服务的。上面目录中的文件除去后缀.xml就是在 firewalld 的服务列表中显示的服务名称。\n下面展示下 ssh 服务的定义文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;service\u0026gt;  \u0026lt;short\u0026gt;SSH\u0026lt;/short\u0026gt;  \u0026lt;description\u0026gt;Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.\u0026lt;/description\u0026gt;  \u0026lt;port protocol=\u0026#34;tcp\u0026#34; port=\u0026#34;22\u0026#34;/\u0026gt; \u0026lt;/service\u0026gt;  short 标签是服务的简称； description 标签是服务的描述，建议添加描述，以便在需要审核服务时获得更多信息； port 标签是要开放的端口号和协议，可以多次指定或者批量；  \u0026lt;!-- 单端口 --\u0026gt; \u0026lt;port protocol=\u0026#34;tcp\u0026#34; port=\u0026#34;80\u0026#34;/\u0026gt;  \u0026lt;!-- 多端口 --\u0026gt; \u0026lt;port protocol=\u0026#34;tcp\u0026#34; port=\u0026#34;80\u0026#34;/\u0026gt; \u0026lt;port protocol=\u0026#34;tcp\u0026#34; port=\u0026#34;8080\u0026#34;/\u0026gt; ... ...  \u0026lt;!-- 批量 --\u0026gt; \u0026lt;port protocol=\u0026#34;tcp\u0026#34; port=\u0026#34;10000-12000\u0026#34;/\u0026gt; 保存好文件后需要执行一次 firewall-cmd --reload 才能识别到\n参考资料 #   如何在 CentOS7 上使用 FirewallD 设置防火墙\n"},{"id":29,"href":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/mailx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","title":"Mailx安装与使用","section":"Linux","content":"Mailx 安装与使用 #  Mailx 安装 #  安装 #  执行命令\nsudo yum install -y mailx 配置 #  在配置文件 /etc/mail.rc 后面追加\n set from=username@domain # 对方收到邮件时显示的发件人   set smtp=smtp.domain.com # 指定第三方发送邮件的smtp服务器地址   set smtp-auth-user=username@domain # 第三方发邮件的用户名   set smtp-auth-password=\u0026#34;password\u0026#34; # 用户名对应密码或授权码   set smtp-auth=login # SMTP的认证方式。默认是LOGIN，也可改为CRAM-MD5或PLAIN方式 Mailx的使用 #  可以使用 mail -h 查看帮助\nmail: option requires an argument -- h Usage: mail -eiIUdEFntBDNHRVv~ -T FILE -u USER -h hops -r address -s SUBJECT -a FILE -q FILE -f FILE -A ACCOUNT -b USERS -cUSERS -S OPTION users 无正文的邮件 #  mail -s \u0026#34;subject\u0026#34; qs@coderqs.com 注：不知道是我的版本的问题还是其他原因，我使用这种方式是发不出去邮件的，执行后一直没有响应，程序像是挂起了一样，既不发送也不结束。\n有正文的邮件 #  从文件中导入正文 #  mail -s \u0026#34;subject\u0026#34; qs@coderqs.com \u0026lt; message_body.txt 或者\ncat message_body.txt | mail -s \u0026#34;subject\u0026#34; qs@coderqs.com 从命令行导入正文 #  echo \u0026#34;massage body content\u0026#34; | mail -s \u0026#34;subject\u0026#34; qs@coderqs.com 带附件的邮件 #  mail -s \u0026#34;subject\u0026#34; qs@coderqs.com -a attachment.tar.gz 参考资料 #   Linux发邮件之mail命令详解\nmail 参数详解\n"},{"id":30,"href":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%8D%87%E7%BA%A7gcc/","title":"升级gcc","section":"Linux","content":"升级 GCC #  编译 GCC #  下载源码 #  方法一 #  在 gcc官方镜像下载源码的压缩包\nwget http://ftp.gnu.org/gnu/gcc/gcc-8.4.0/gcc-8.4.0.tar.gz tar -zxvf gcc-8.4.0.tar.gz 方法二 #  在 github上载，注意这种方式是展开的源码，文件较多较大，下载时间可能更长\ngit clone https://github.com/gcc-mirror/gcc.git 安装依赖 #  yum install -y gmp gmp-devel mpfr mpfr-devel libmpc libmpc-devel 编译安装 #  mkdir gcc-8.4.0-build \u0026amp;\u0026amp; cd gcc-8.4.0-build ../gcc-8.4.0/configure --enable-languages=c,c++ --disable-multilib make -j $(nproc) configure 更多的配置选项在 这里查看\n注意：编译之前要保证 /tmp 有足够多的磁盘空间！\n安装 #  make install 添加环境变量 编译默认的安装路径是 /usr/local/bin, 在 /etc/profile 中追加\nexport PATH=/usr/local/bin:$PATH export LD_LIBRARY_PATH=/usr/local/lib64:$LD_LIBRARY_PATH 修改完成后保存，使其生效\nsource /etc/profile 验证 #  gcc --version 输出\n使用内建 specs。 COLLECT_GCC=gcc COLLECT_LTO_WRAPPER=/usr/local/libexec/gcc/x86_64-pc-linux-gnu/8.4.0/lto-wrapper 目标：x86_64-pc-linux-gnu 配置为：../gcc-8.4.0/configure --enable-languages=c,c++ --disable-multilib 线程模型：posix gcc 版本 8.4.0 (GCC) 修改软连接 #  ln -sf /usr/local/lib64/libstdc++.so.6.0.25 /usr/lib64/libstdc++.so.6 ln -sf /usr/local/bin/gcc /usr/bin/cc 注：如果之前未安装过 gcc，到这里应该就结束了，但之前有就需要将旧的卸载(因为我解决不了两个版本共存的冲突问题)，并链接新的 libstdc++\n遇到的问题 #  Building GCC requires GMP 4.2 , MPFR 2.4.0 and MPC 0.8.0 . #  缺少依赖项，使用\nyum install -y fatal error: Killed signal terminated program cc1plus #  原因是内存不够了（vps 内存就512m），可以通过添加虚拟内存来解决，虚拟内存的增加方法可参考《 解决编译GCC内存不足的错误》和《 设置和修改Linux的swap分区大小》\n通过 yum 升级 #   Software Collections（也称为SCL）是一个社区项目，使您可以在同一系统上构建，安装和使用多个版本的软件，而不会影响系统默认软件包。通过启用软件集合，您可以访问核心存储库中不可用的较新版本的编程语言和服务。\nSCL 存储库提供了一个名为 Developer Toolset 的程序包，其中包括 GNU Compiler Collection 的较新版本以及其他开发和调试工具。\n首先，安装 CentOS SCL 发行文件。它是 CentOS Extras 存储库的一部分，可以通过运行以下命令进行安装\nyum install -y centos-release-scl 当前，可以使用以下开发人员工具集集合：\n Developer Toolset 7 Developer Toolset 6  在此示例中，我们将安装 Developer Toolset 版本 7。运行以下命令：\nyum install -y devtoolset-7 要访问 GCC 版本 7，需要使用 scl 工具启动新的 Shell 实例\nscl enable devtoolset-7 bash 执行完成后查看gcc的版本\ngcc --version 输出\ngcc (GCC) 7.3.1 20180303 (Red Hat 7.3.1-5) Copyright (C) 2017 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 详情可参考 《如何在 CentOS7 上安装GCC编译器》安装多个GCC版本的部分\n"},{"id":31,"href":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/%E6%95%85%E9%9A%9C%E8%AE%B0%E5%BD%95/linux%E8%84%9A%E6%9C%AC%E8%87%AA%E5%B7%B1%E5%8F%AF%E4%BB%A5%E5%8D%95%E7%8B%AC%E6%89%A7%E8%A1%8C%E4%BD%86%E5%9C%A8service%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%B0%B1%E9%94%99%E8%AF%AF/","title":"Linux脚本自己可以单独执行但在service文件中使用就错误","section":"故障记录","content":"脚本可单独执行，在 .service 文件中使用就报错 #  背景 #  想要给树莓派添加个服务，每次开机后把 ip 发送到指定邮箱。结果配置好了后总是启动不起来，查看日志发现没有权限 Failed to execute command: Permission denied\n-- Unit send_ip.service has begun starting up. Sep 14 16:33:01 bogon systemd[11178]: send_ip.service: Failed to execute command: Permission denied Sep 14 16:33:01 bogon systemd[11178]: send_ip.service: Failed at step EXEC spawning /usr/bin/script/send_ip.sh: Permission denied -- Subject: Process /usr/bin/script/send_ip.sh could not be executed -- Defined-By: systemd -- Support: https://access.redhat.com/support -- -- The process /usr/bin/script/send_ip.sh could not be executed and failed. -- -- The error number returned by this process is 13. Sep 14 16:33:01 bogon systemd[1]: send_ip.service: Control process exited, code=exited status=203 Sep 14 16:33:01 bogon systemd[1]: send_ip.service: Failed with result \u0026#39;exit-code\u0026#39;. Sep 14 16:33:01 bogon systemd[1]: Failed to start 开机后向管理员发送本机的ip. -- Subject: Unit send_ip.service has failed -- Defined-By: systemd -- Support: https://access.redhat.com/support -- -- Unit send_ip.service has failed. 已确认脚本确实是正确的，service 文件如下\n[Unit] Description=开机后向管理员发送本机的ip After=network.target  [Service] Type=forking User=root ExecStart=/usr/bin/script/send_ip.sh PrivateTmp=true  [Install] WantedBy=multi-user.target 查了下 code=exited status=203 表示 systemctl 执行脚本时需要知道脚本的解释器，可脚本前面明明有写 #!/bin/bash\n原因 #  203 的错误提示没有错，确实是系统不知道脚本的解释，只是这里不应该是在脚本开头加 #!/bin/bash，而是在 ExecStart 里声明使用的解释器，将 ExecStart=/usr/bin/script/send_ip.sh 修改为 ExecStart=/bin/bash /usr/bin/script/send_ip.sh\n修改后的 service 文件应该如下\n[Unit] Description=开机后向管理员发送本机的ip After=network.target  [Service] Type=forking User=root ExecStart=/bin/bash /usr/bin/script/send_ip.sh PrivateTmp=true  [Install] WantedBy=multi-user.target 参考资料 #   修复systemd服务203 / EXEC故障（无此类文件或目录）\n"},{"id":32,"href":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%9F%A5%E7%9C%8B%E5%BA%93%E7%9A%84%E7%AC%A6%E5%8F%B7/","title":"查看库的符号","section":"Linux","content":"查看库的符号 #  查看生成的so是否存在符号未定义的内容 #  ldd -r xxx.so 查看 so 中的所有符号 #  nm xxx.so 例如下面是 nm 输出的结果中的一段:\n U _ZN11CHttpParser20GetCurrentHttpMethodER13http_method_t U _ZN11CHttpParser26ExactResultFromHttpMsgBodyESsRSs U _ZN11CHttpParser5parseESs U _ZN11CHttpParserC1ESs 00000000000134e6 W _ZN5boost10shared_ptrI11CHttpParserE4swapERS2_ 0000000000012e56 W _ZN5boost10shared_ptrI11CHttpParserEC1ERKS2_ 0000000000012e30 W _ZN5boost10shared_ptrI11CHttpParserEC1Ev 0000000000014cda W _ZN5boost10shared_ptrI11CHttpParserEC1IS1_EEPT_ 0000000000012cda W _ZN5boost10shared_ptrI11CHttpParserED1Ev 0000000000013df4 W _ZN5boost10shared_ptrI11CHttpParserEaSERKS2_ 000000000001348b W _ZN5boost14checked_deleteI11CHttpParserEEvPT_ 其输出的结果是以 地址 类型 符号名 的结构显示的，其中一些常见的符号类型如下\n   nm输出字符 含义     R Read only symbol. 比如在代码中有一个const MAXDATA = 3095; 则MAXDATA就是一个Read only symbol   N 这是一个调试符号   D 这是一个已经初始化的变量的符号。比如代码中int i = 1和char *str = \u0026ldquo;Hello\u0026quot;则i和str都是这种类型的符号   T Text段的符号。子程序都是这种符号，比如文件中实现了一个函数function，则function就是这种符号   U 未定义的符号。如果文件中引用了不存在的函数，则这些未定义的函数符号就是这种类型   S 未初始化的符号，比如全局变量int s;则s的符号就是此类型    参考资料 #   Linux下使用nm命令排查和解决“undefined referenceto”\nundefined symbol问题的查找、定位与解决方法\n"},{"id":33,"href":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%8C%BA/","title":"设置系统时区","section":"Linux","content":"方法一：timedatectl #  timedatectl 是一个命令行工具，它允许你查看并且修改系统时间和日期。它在所有现代的基于 systemd 的 Linux 系统中都可以使用。\n检查时区 #  执行下面命令：\ntimedatectl 执行后会显示系统的时区。我的机器显示如下：\nLocal time: Sat 2021-02-19 17:02:22 UTC  Universal time: Sat 2021-02-19 17:02:22 UTC  RTC time: Sat 2021-02-19 17:02:22  Time zone: UTC (UTC, +0000) System clock synchronized: yes  NTP service: active  RTC in local TZ: no 可以看到我的机器的时区 Time zone: UTC (UTC, +0000) 是 UTC\n修改时区 #  在修改时区时，需要找到想要使用的时区的名字，一般的格式是地区/城市。不知道名字的话可以使用 timedatectl list-timezones 命令来查看，执行后显示如下：\nAfrica/Abidjan Africa/Accra Africa/Addis_Ababa Africa/Algiers Africa/Asmara ... 找到自己要使用的时区后进行设置，比如我这里使用的是 Asia/Shanghai，以 root 或 sudo 执行下面的命令：\n sudo timedatectl set-timezone Asia/Shanghai 命令执行完成后后再次执行 timedatectl 来检查是否设置成功\n Local time: Fri 2021-02-19 17:03:47 CST  Universal time: Fri 2021-02-19 09:03:47 UTC  RTC time: Fri 2021-02-19 09:03:47  Time zone: Asia/Shanghai (CST, +0800)  System clock synchronized: yes  NTP service: active  RTC in local TZ: no 可以看到已经修改成功了。\n方法二：创建链接 #  当系统版本较低或timedatectl 不可用时，可以通过修改时区的链接文件 /etc/localtime，将其链接到 /usr/share/zoneinfo 目录下的时区文件来修改时区。\n查看时区 #  执行下面命令：\ndate 执行后，我的机器显示如下：\nFri Feb 19 09:49:20 UTC 2021 修改时区 #  在 /usr/share/zoneinfo 下找到你想要修改成的时区，然后创建链接文件 /etc/localtime。以我使用的 Asia/Shanghai 为例，执行下面命令\nsudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 执行完成后使用 date 检查是否修改成功，我的机器显示如下：\nFri Feb 19 17:50:00 CST 2021 可以看到已经修改成功了。\n参考资料 #   如何在 CentOS 8 设置或者修改时区\n"},{"id":34,"href":"/%E6%A1%86%E6%9E%B6_%E5%BA%93/jsoncpp%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Jsoncpp的使用","section":"框架/库","content":"Jsoncpp 使用方法 #  jsoncpp 源码\n示例 #  以这个 json 串为例\n{  \u0026#34;item_0\u0026#34;:\u0026#34;一个普通的 json 元素\u0026#34;,  \u0026#34;arrary\u0026#34;:[\u0026#34;数组元素1\u0026#34;, \u0026#34;数组元素1\u0026#34;],  \u0026#34;empty_arrary\u0026#34;:[],  \u0026#34;item_1\u0026#34;:{  \u0026#34;item_item_0\u0026#34;:\u0026#34;\u0026#34;,  \u0026#34;item_item_1\u0026#34;:\u0026#34;\u0026#34;  } } 使用 在线工具检查 json 字符串是否合法，以及格式化、压缩转义等。\n解析 json #  示例代码\n int ParseJson(std::string json_str)  {  Json::Reader reader;  Json::Value root;   try {  if (reader.parse(json_str, root)) {  if (root.isMember(\u0026#34;item_0\u0026#34;))  std::cout \u0026lt;\u0026lt; root[\u0026#34;item_0\u0026#34;].asString() \u0026lt;\u0026lt; std::endl;   if (root.isMember(\u0026#34;array\u0026#34;)) {  Json::Value val;  val = root[\u0026#34;array\u0026#34;];  for (int i = 0; i \u0026lt; val.size(); ++i) {  std::cout \u0026lt;\u0026lt; \u0026#34;array: \u0026#34; \u0026lt;\u0026lt; val[i].asString() \u0026lt;\u0026lt; std::endl;  }  std::cout \u0026lt;\u0026lt; \u0026#34;array size: \u0026#34; \u0026lt;\u0026lt; val.size() \u0026lt;\u0026lt; std::endl;  }   if (root.isMember(\u0026#34;empty_array\u0026#34;)) {  Json::Value val;  val = root[\u0026#34;empty_array\u0026#34;];  for (int i = 0; i \u0026lt; val.size(); ++i) {  std::cout \u0026lt;\u0026lt; \u0026#34;empty_array: \u0026#34; \u0026lt;\u0026lt; val[i].asString() \u0026lt;\u0026lt; std::endl;  }  std::cout \u0026lt;\u0026lt; \u0026#34;empty_array size: \u0026#34; \u0026lt;\u0026lt; val.size() \u0026lt;\u0026lt; std::endl;  }   if (root.isMember(\u0026#34;item_1\u0026#34;)) {  Json::Value val;  val = root[\u0026#34;item_1\u0026#34;];  if (val.isMember(\u0026#34;item_item_0\u0026#34;)) {  std::cout \u0026lt;\u0026lt; \u0026#34;item_1.item_item_0 \u0026#34; \u0026lt;\u0026lt; val[\u0026#34;item_item_0\u0026#34;].asString() \u0026lt;\u0026lt; std::endl;  }  if (val.isMember(\u0026#34;item_item_1\u0026#34;)) {  std::cout \u0026lt;\u0026lt; \u0026#34;item_1.item_item_1 \u0026#34; \u0026lt;\u0026lt; val[\u0026#34;item_item_1\u0026#34;].asString() \u0026lt;\u0026lt; std::endl;  }  }  }  }  catch (...)  {  std::cout \u0026lt;\u0026lt; \u0026#34;error\u0026#34; \u0026lt;\u0026lt; std::endl;  }  return 0;  } 转为 json #   int GenerateJson(Json::Value\u0026amp; root) {  std::string str = \u0026#34;一个普通的 json 元素\u0026#34;;  root[\u0026#34;item_0\u0026#34;] = str.c_str();  Json::Value val;  for (int i = 0; i \u0026lt; 3; ++i) {  val.append(\u0026#34;数组元素1\u0026#34;);  }  root[\u0026#34;array\u0026#34;] = val;  root[\u0026#34;empty_array\u0026#34;] = Json::arrayValue;   Json::Value item;  item[\u0026#34;item_item_0\u0026#34;] = \u0026#34;item_item_0\u0026#34;;  item[\u0026#34;item_item_1\u0026#34;] = \u0026#34;item_item_1\u0026#34;;  root[\u0026#34;item_1\u0026#34;] = item;   Json::FastWriter json_fw;  std::cout \u0026lt;\u0026lt; \u0026#34;无格式的 Json: \u0026#34; \u0026lt;\u0026lt; json_fw.write(root) \u0026lt;\u0026lt; std::endl;   Json::StyledWriter json_sw;  std::cout \u0026lt;\u0026lt; \u0026#34;有格式的 Json: \u0026#34; \u0026lt;\u0026lt; json_sw.write(root) \u0026lt;\u0026lt; std::endl;  return 0;  } 其他接口 #  接口的详细介绍可以参考 jsoncpp 官方文档\n类型判断 #  isNull: 是否为空\nisBool: 是否为布尔值\nisInt: 是否为 int\nisArray: 是否为数组\nisMember: 是否存在该项\nisValidIndex:\n类型转换 #  asInt\nasString\n\u0026hellip;\n节点获取 #  get\n[]\n节点操作 #  compare\nswap\nremoveMember\nremoveindex\nappend\n完整示例代码 #  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt; #include \u0026#34;json/json.h\u0026#34; const char* kJsonStr = \u0026#34;{\u0026#34; \u0026#34;\\\u0026#34;item_0\\\u0026#34;:\\\u0026#34;一个普通的 json 元素\\\u0026#34;,\u0026#34; \u0026#34;\\\u0026#34;array\\\u0026#34;:[\\\u0026#34;数组元素0\\\u0026#34;, \\\u0026#34;数组元素1\\\u0026#34;],\u0026#34; \u0026#34;\\\u0026#34;empty_array\\\u0026#34;:[],\u0026#34; \u0026#34;\\\u0026#34;item_1\\\u0026#34;:{\u0026#34; \u0026#34;\\\u0026#34;item_item_0\\\u0026#34;:\\\u0026#34;\\\u0026#34;,\u0026#34; \u0026#34;\\\u0026#34;item_item_1\\\u0026#34;:\\\u0026#34;\\\u0026#34;\u0026#34; \u0026#34; }\u0026#34; \u0026#34;}\u0026#34;;  Json::Value ParseJson(std::string json_str) {  Json::Reader reader;  Json::Value root;   try {  if (reader.parse(json_str, root)) {  if (root.isMember(\u0026#34;item_0\u0026#34;))  std::cout \u0026lt;\u0026lt; root[\u0026#34;item_0\u0026#34;].asString() \u0026lt;\u0026lt; std::endl;   if (root.isMember(\u0026#34;array\u0026#34;)) {  Json::Value val;  val = root[\u0026#34;array\u0026#34;];  for (int i = 0; i \u0026lt; val.size(); ++i) {  std::cout \u0026lt;\u0026lt; \u0026#34;array: \u0026#34; \u0026lt;\u0026lt; val[i].asString() \u0026lt;\u0026lt; std::endl;  }  std::cout \u0026lt;\u0026lt; \u0026#34;array size: \u0026#34; \u0026lt;\u0026lt; val.size() \u0026lt;\u0026lt; std::endl;  }   if (root.isMember(\u0026#34;empty_array\u0026#34;)) {  Json::Value val;  val = root[\u0026#34;empty_array\u0026#34;];  for (int i = 0; i \u0026lt; val.size(); ++i) {  std::cout \u0026lt;\u0026lt; \u0026#34;empty_array: \u0026#34; \u0026lt;\u0026lt; val[i].asString() \u0026lt;\u0026lt; std::endl;  }  std::cout \u0026lt;\u0026lt; \u0026#34;empty_array size: \u0026#34; \u0026lt;\u0026lt; val.size() \u0026lt;\u0026lt; std::endl;  }   if (root.isMember(\u0026#34;item_1\u0026#34;)) {  Json::Value val;  val = root[\u0026#34;item_1\u0026#34;];  if (val.isMember(\u0026#34;item_item_0\u0026#34;)) {  std::cout \u0026lt;\u0026lt; \u0026#34;item_1.item_item_0 \u0026#34; \u0026lt;\u0026lt; val[\u0026#34;item_item_0\u0026#34;].asString() \u0026lt;\u0026lt; std::endl;  }  if (val.isMember(\u0026#34;item_item_1\u0026#34;)) {  std::cout \u0026lt;\u0026lt; \u0026#34;item_1.item_item_1 \u0026#34; \u0026lt;\u0026lt; val[\u0026#34;item_item_1\u0026#34;].asString() \u0026lt;\u0026lt; std::endl;  }  }  }  }  catch (...)  {  std::cout \u0026lt;\u0026lt; \u0026#34;error\u0026#34; \u0026lt;\u0026lt; std::endl;  }  return root; }  int GenerateJson(Json::Value\u0026amp; root,  std::string\u0026amp; not_format_json,  std::string\u0026amp; format_json) {  std::string str = \u0026#34;一个普通的 json 元素\u0026#34;;  root[\u0026#34;item_0\u0026#34;] = str.c_str();  Json::Value val;  for (int i = 0; i \u0026lt; 3; ++i) {  val.append(\u0026#34;数组元素1\u0026#34;);  }  root[\u0026#34;array\u0026#34;] = val;  root[\u0026#34;empty_array\u0026#34;] = Json::arrayValue;   Json::Value item;  item[\u0026#34;item_item_0\u0026#34;] = \u0026#34;item_item_0\u0026#34;;  item[\u0026#34;item_item_1\u0026#34;] = \u0026#34;item_item_1\u0026#34;;  root[\u0026#34;item_1\u0026#34;] = item;   Json::FastWriter json_fw;  not_format_json = json_fw.write(root);   Json::StyledWriter json_sw;  format_json = json_sw.write(root);  return 0; }  int main(int argc, char** argv) {  std::cout \u0026lt;\u0026lt; \u0026#34;原始数据：\u0026#34; \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; kJsonStr \u0026lt;\u0026lt; std::endl;  std::cout \u0026lt;\u0026lt; \u0026#34;开始解析 json\u0026#34; \u0026lt;\u0026lt; std::endl;  Json::Value root = ParseJson(kJsonStr);  std::cout \u0026lt;\u0026lt; \u0026#34;json 解析完毕\u0026#34; \u0026lt;\u0026lt; std::endl;   std::string not_format_json, format_json;  GenerateJson(root, not_format_json, format_json);   std::cout \u0026lt;\u0026lt; \u0026#34;无格式的 Json: \u0026#34; \u0026lt;\u0026lt; not_format_json \u0026lt;\u0026lt; std::endl;  std::cout \u0026lt;\u0026lt; \u0026#34;有格式的 Json: \u0026#34; \u0026lt;\u0026lt; format_json \u0026lt;\u0026lt; std::endl;   return 0; } 参考资料 #   JsonCpp使用方法详解\n使用 jsoncpp 创建空的 json数组\nC++通过jsoncpp类库读写JSON文件\n"},{"id":35,"href":"/%E7%BD%91%E7%BB%9C/%E4%BD%BF%E7%94%A8cloudflare%E5%90%8E%E6%97%A0%E9%99%90%E8%B7%B3%E8%BD%AC/","title":"使用cloudflare后无限跳转","section":"网络","content":"使用 Cloudflare 后网站无限 301 跳转 #  原因分析 #  出现这个故障的大部分服务器都是因为服务器端使用了强制 HTTPS，而 CloudFlare 的 Flexible 策略原理是：用户访问时使用 HTTPS 访问到 CF 的节点，然后 CF 通过HTTP方式回源到你的服务器去读取数据，这个时候对于你的服务器来说，CF 就是访客，所以服务器返回的状态都是 301。\n解决方法 #  将 CloudFlare 的 SSL 策略设为 Full 或者 Full(strict) 就能解决。\n扩展 #  CloudFlare 的 SSL 可选模式 #   Off：关闭SSL，全程使用 HTTP； Flexible：A 使用 HTTPS，B 使用 HTTP，称为灵活加密； Full：AB全程使用 HTTPS，允许 B 程服务端使用自签名证书； Full(strict)：全程使用 HTTPS，与 Full 的区别在于服务端必须使用有效的可信任证书；  参考资料 #   CDN访问异常篇之重定向的次数过多\nCloudflare开启HTTPS/SSL后无限301跳转的解决方法\n"},{"id":36,"href":"/%E7%BD%91%E7%BB%9C/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/v2ray/v2ray%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","title":"V2ray安装与配置","section":"V2ray","content":"V2ray 的安装与配置 #  V2ray 安装 #  下载安装脚本 #  curl -O https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh curl -O https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-dat-release.sh  其中 install-release.sh 用于安装最新版本的 V2ray 的程序，install-dat-release.sh 用于安装geoip.dat和geosite.dat的最新版本。\n安装 V2ray #  执行下面命令安装 V2ray\nbash install-release.sh 安装的文件结构如下\n/usr/local/bin/v2ray /usr/local/bin/v2ctl /usr/local/share/v2ray/geoip.dat /usr/local/share/v2ray/geosite.dat /usr/local/etc/v2ray/config.json /var/log/v2ray/ /var/log/v2ray/access.log /var/log/v2ray/error.log /etc/systemd/system/v2ray.service /etc/systemd/system/v2ray@.service  安装更新 geo 相关的文件\nbash install-dat-release.sh  非官方安装脚本 #  脚本的安装命令如下：\nwget -P /root -N --no-check-certificate \u0026quot;https://raw.githubusercontent.com/mack-a/v2ray-agent/master/install.sh\u0026quot; \u0026amp;\u0026amp; chmod 700 /root/install.sh \u0026amp;\u0026amp; /root/install.sh  这个脚本在很多教程中看到过，安装起来确实也方便很多，还支持自动配置常用的几种科学上网方式，其支持的安装类型如下\n* VLESS+TCP+TLS\n VLESS+TCP+xtls-rprx-direct VLESS+WS+TLS【支持CDN、IPv6】 VMess+TCP+TLS VMess+WS+TLS【支持CDN、IPv6】 Trojan Trojan-Go+WS【支持CDN、不支持IPv6】  关于脚本的详细内容可以参考其在 Github 上的项目 。\nV2ray 配置 #  可以参考官方在 GitHub 上给出的示例 。\n创建为系统服务 #  在目录 /usr/lib/systemd/system/ 下创建文件 v2ray.service，在其中添加如下内容\n[Unit] Description=V2Ray - A unified platform for anti-censorship Documentation=https://v2ray.com https://guide.v2fly.org After=network.target nss-lookup.target Wants=network-online.target [Service] Type=simple User=root CapabilityBoundingSet=CAP_NET_BIND_SERVICE CAP_NET_RAW NoNewPrivileges=yes ExecStart=/usr/local/bin/v2ray -config /usr/local/etc/v2ray/config.json Restart=on-failure RestartPreventExitStatus=23 [Install] WantedBy=multi-user.target  注：以上是一个示例，程序的路径与配置文件根据自己实际情况来更改。 的编写与说明请参阅对应的页面。\n"},{"id":37,"href":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%A7%84%E8%8C%83/","title":"单元测试规范","section":"技术归纳","content":"单元测试规范 #  名词解释 #  覆盖率 #  覆盖率是对自动化测试运行期间执行了多少代码产生的度量（100%覆盖意味着每一行代码都至少执行过） 不必追求100%的覆盖率，覆盖率在60%-80%是一个不错的范围，这个主要根据项目的情况来决定。\n单元测试原则 #   DAMP 和DRY 这是一种平衡，而不是矛盾\nDAMP 和 DRY 并不矛盾，而是平衡了代码可维护性的两个不同方面。可维护的代码（易于更改的代码）是这里的最终目标。\nDAMP（描述性和有意义的短语）提高了代码的可读性。\n要维护代码，首先需要了解代码。要理解它，你必须阅读它。考虑一下你花多少时间阅读代码。这是很多。 DAMP 通过减少阅读和理解代码所需的时间来提高可维护性。\nDRY（不要重复自己）促进代码的 正交性。\n删除重复确保系统中的每个概念在代码中都有一个单一的权威表示。对单个业务概念的更改会导致对代码的一次更改。DRY 通过将更改（风险）隔离到系统中必须更改的那些部分来提高可维护性。\n那么，为什么重复在测试中更容易接受？\n测试通常包含固有的重复，因为它们一遍又一遍地测试相同的东西，只是输入值或设置代码略有不同。但是，与生产代码不同的是，这种重复通常仅与单个测试夹具/文件中的场景隔离。因此，重复是最小的和明显的，这意味着它比其他类型的重复给项目带来的风险更小。\n此外，删除这种重复会降低测试的可读性。以前在每个测试中重复的细节现在隐藏在一些新方法或类中。为了全面了解测试，您现在必须在精神上将所有这些部分重新组合在一起。\n因此，由于测试代码重复通常带来的风险较小，并提高了可读性，因此很容易看出它是如何被认为是可以接受的。\n原则上，在生产代码中使用 DRY，在测试代码中使用 DAMP。虽然两者同等重要，但只要稍加智慧，您就可以在对自己有利的情况下平衡。\n引用自： 在谈论单元测试时，\u0026ldquo;DAMP not DRY\u0026quot;是什么意思？\n 单元测试的准则 #   单元测试应该是可靠的，否则不能保证测试结果可信;  单元测试应该是可维护且易于阅读和理解的; 单元测试的每一个测试单元只测试一个用例，这样便于维护; 单元测试应该可以在任何机器上顺序运行，且不会相互影响，如果可以，希望也能不依赖环境因素或全局/外部状态; 单元测试应该自动化; 结合使用单元测试和集成测试; 单元测试应在有组织的测试实践中执行;    单元测试用例的命名方法 #  这里提供以下七种命名方法以供参考\nMethodName_StateUnderTest_ExpectedBehavior(方法名_在测试状态_预期行为) #  如果方法名在重构的时候被更改，那么测试用例也应该同样被更改，否则以后会难以被理解。示例：\nisAdult_AgeLessThan18_False\nwithdrawMoney_InvalidAccount_ExceptionThrown\nadmitStudent_MissingMandatoryFields_FailToAdmit\nMethodName_ExpectedBehavior_StateUnderTest(方法名_预期行为_在测试状态) #  与第一种有相同的问题。示例：\nisAdult_False_AgeLessThan18\nwithdrawMoney_ThrowsException_IfAccountIsInvalid\nadmitStudent_FailToAdmit_IfMandatoryFieldsAreMissing\ntest[Feature being tested](test要测试的功能) #  将要测试的功能作为测试名称，增加了可读性。示例：\ntestIsNotAnAdultIfAgeLessThan18\ntestFailToWithdrawMoneyIfAccountIsInvalid\ntestStudentIsNotAdmittedIfMandatoryFieldsAreMissing\n也可以选择去掉前缀test。示例：\nIsNotAnAdultIfAgeLessThan18\nFailToWithdrawMoneyIfAccountIsInvalid\nStudentIsNotAdmittedIfMandatoryFieldsAreMissing\nShould_ExpectedBehavior_When_StateUnderTest(Should_预期行为_When_在测试状态) #  Should_ThrowException_When_AgeLessThan18\nShould_FailToWithdrawMoney_ForInvalidAccount\nShould_FailToAdmit_IfMandatoryFieldsAreMissing\nWhen_StateUnderTest_Expect_ExpectedBehavior(When_在测试状态_Expect_预期行为) #  When_AgeLessThan18_Expect_isAdultAsFalse\nWhen_InvalidAccount_Expect_WithdrawMoneyToFail\nWhen_MandatoryFieldsAreMissing_Expect_StudentAdmissionToFail\nGiven_Preconditions_When_StateUnderTest_Then_ExpectedBehavior(Given_先决条件_When_在测试状态_Expect_预期行为) #  此方法基于作为行为驱动开发（BDD）一部分开发的命名约定。想法是将测试分为三部分，以便可以提出先决条件，测试状态和预期行为，并以上述格式编写。示例：\nGiven_UserIsAuthenticated_When_InvalidAccountNumberIsUsedToWithdrawMoney_Then_TransactionsWillFail\n参考资料 #   在马桶上测试：测试过干吗？让他们成为DAMP！\n单元测试最佳实践：如何最大程度地利用测试自动化\n7种流行的单元测试命名约定\nTDD–测试驱动开发入门\n单元测试的命名标准\n"},{"id":38,"href":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E7%AE%A1%E7%90%86/","title":"版本号的管理","section":"技术归纳","content":"版本号的管理 #  前言 #  在现代软件开发过程中，相较于“重复造轮子”，开发者往往会利用一些已有的组件（如库、程序、多媒体文件）进行开发。程序开发者根据特定版本的组件来设计自己的软件。这种方式使得代码重复利用，减少了开发的工作量，降低了开发门槛。但是该软件要正确运行，必须安装了指定版本的某些组件。\n==== 依赖地狱 ==== 操作系统中由于软件之间的依赖性不能被满足而引发的问题称为依赖地狱。依赖地狱主要有以下表现：\n  依赖过多：一个软件包可能依赖于众多的库，因此安装一个软件包的同时要安装几个甚至几十个库包。 #  多重依赖：指从所需软件包到最底层软件包之间的层级数过多。这会导致依赖性解析过于复杂，并且容易产生依赖冲突和环形依赖。 #  依赖冲突：即两个软件包无法共存的情况。除两个软件包包含内容直接冲突外，也可能因为其依赖的低层软件包互相冲突。因此，两个看似毫无关联的软件包也可能因为依赖性冲突而无法安装。  依赖循环：即依赖性关系形成一个闭合环路，最终导致：在安装 A 软件包之前，必须要安装 A、B、C、D 软件包，然而这是不可能的。    版本号风格总结 #  GUN 风格 #  命名格式 #  主版本号 . 子版本号 [. 修正版本号 build- [编译版本号 ]]\n示例：\n 1.2 1.2.0 1.2.0 build-1234  规范 #   项目初版本时，版本号可以是 0.1 或 0.1.0，可以是 1.0 或 1.0.0，建议主版本号从 0 开始;  当项目在进行了局部修改或 bug 修正时，主版本号和子版本号都不变，修正版本号加 1; 当项目在原有的基础上增加了部分功能时，主版本号不变，子版本号加 1，修正版本号复位为 0，因而可以被忽略掉; 当项目在进行了重大修改或局部修正累积较多，而导致项目整体发生全局变化时，主版本号加 1; 编译版本号一般是编译器在编译过程中自动生成的，我们只定义其格式，并不进行人为控制;    Windows 风格 #  命名格式 #  主版本号 . 子版本号 [ 修正版本号 [. 编译版本号 ]]\n示例：\n 1.2.0.1234  规范 #   项目初版，版本号为 1.0 或 1.00;  当项目在进行了局部修改或 bug 修正时，主版本号和子版本号都不变，修正版本号加 1; 当项目在原有的基础上增加了部分功能时，主版本号不变，子版本号加 1，修正版本号复位为 0，因而可以被忽略掉 ; 当项目在进行了重大修改或局部修正累积较多，而导致项目整体发生全局变化时，主版本号加 1; 编译版本号一般是编译器在编译过程中自动生成的，我们只定义其格式，并不进行人为控制 ;   还可以在版本号后面加入 Alpha,Beta,Gamma,Current,RC (Release Candidate),Release,Stable 等后缀，在这些后缀后面还可以加入 1 位数字的版本号;  对于用户来说，如果某个软件的主版本号进行了升级，用户还想继续那个软件，则发行软件的公司一般要对用户收取升级费用 ; 而如果子版本号或修正版本号发生了升级，一般来说是免费的.\nNet Framework 风格 #  命名格式 #  主版本号.子版本号[.编译版本号[.修正版本号]]\n规范 #   主版本号和次版本号是必选的；内部版本号和修订号是可选的，但是如果定义了修订号部分，则内部版本号就是必选的。  所有定义的部分都必须是大于或等于 0 的整数。 应根据下面的约定使用这些部分： Major：具有相同名称但不同主版本号的程序集不可互换。例如，这适用于对产品的大量重写，这些重写使得无法实现向后兼容性。   Minor：如果两个程序集的名称和主版本号相同，而次版本号不同，这指示显著增强，但照顾到了向后兼容性。例如，这适用于产品的修正版或完全向后兼容的新版本。 Build：内部版本号的不同表示对相同源所作的重新编译。这适合于更改处理器、平台或编译器的情况。 Revision：名称、主版本号和次版本号都相同但修订号不同的程序集应是完全可互换的。这适用于修复以前发布的程序集中的安全漏洞。程序集的只有内部版本号或修订号不同的后续版本被认为是先前版本的修补程序 (Hotfix) 更新。    一些版本号中的修饰词的含义 #     修饰词 含义     alpha 内部版本   beta 测试版   demo 演示版   enhance 增强版   free 自由版   full version 完整版，即正式版   lts 长期维护版本   release 发行版   rc 即将作为正式版发布   standard 标准版   ultimate 旗舰版   upgrade 升级版    注：严格来说上面这些并不是版本号，一般在版本号中使用的只有五个，用来表示软件处于那个开发阶段\n base: 基础架构版，此版本包含完整的功能架构，但是功能都没有做完整的实现;  alpha: 内部测试版，此版本表示该软件在该阶段主要是以实现功能为主,Bug 相对较多,需要继续修改,通常只在内部流通流通而不对外开放; beta: 外部测试版，该版本相对 Alpha 已经有了很大的改进,不存在严重的 Bug,但还是存在一些缺陷,需要进一步的测试以检查和消除 Bug; RC: 候选版本，该版本较 beta 版更进一步了，该版本功能不再增加，和最终发布版功能一样。有点像最终发行版之前的一个预览版; release: 最终发行版，是最终交付用户或者公开发布的版本，也称为标准版。需要注意的是，该版本在发布的时候回以符号 R 来代替 Release 单词;    发布周期 #   非紧急情况：首先由测试人员测试并提交 Bug，其次开发人员会尽量在当天修复 Bug 并在第二天发布该版本的 alpha 版，然后由测试人员测试验证关闭 Bug 之后在第三天会发布该版本的 beta 版。 紧急情况：如果 Bug 比较紧急可跳过一般流程，由开发人员尽快修复 Bug，测试确认之后直接发布该版本的 beta 版。  带版本号的软件相关文档的命名方式 #  项目名称 + 文件的描述 + 当前软件的版本号 + _阶段标识\n注：同一版本同一阶段的文件修改过两次以上，则在阶段标识后面加以数字标识，每次修改数字加 1。\n示例：\n 开发规范工程单元测试报告 1.2.0.bate_b(项目名称：开发规范工程，文件的描述：单元测试报告，当前版本号：1.2.0.bate，阶段标识：b)\n* 外包平台设计报告 1.0.0.base_b3  阶段标识 #     阶段名称 阶段标识     需求控制 a   设计阶段 b   编码阶段 c   单元测试 d   单元测试修改 e   集成测试 f   集成测试修改 g   系统测试 h   系统测试修改 i   验收测试 j   验收测试修改 k    参考资料 #   软件修养 - 版本号管理\n关于版本号的总结\n项目管理 - 版本号命名规则\n版本号管理规则\n"},{"id":39,"href":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/cpp%E6%B3%A8%E9%87%8A%E9%A3%8E%E6%A0%BC/","title":"Cpp注释风格","section":"编码规则","content":"C++ 注释风格 #  个人比较认同的三种注释风格\ndoxygen 风格 #  指的是 doxygen 或者基于 doxygen 语法的一些变体的注释。\n这种注释好处是可以直接使用 doxygen 的工具生成文档，但坏处就是太啰嗦，而且这种注释大家在修改代码的时候多数都懒得修改，容易造成注释与代码对不上的情况。\nrustdoc 风格 #  rustdoc 所推荐的注释风格，直接在 /// 型的注释里使用 markdown 语法写注释即可。\n这种注释书写起来很方便，但需要了解 markdown 的语法，对经常使用 markdown 的人员来说非常直观。\n简约风格 #  这种风格提倡在代码中使用良好的命名使代码具有自解释性，以此来适当的减少描述性的注释出现，避免造成代码的不连续。\n这种注释对于命名的能力有着较高要求，毕竟在开发过程中能起一个准确又合适的名字不是一件简单的事情，但是这种风格的代码在看的时候很舒服的。\n使用这种风格有以下几个注意点与建议：\n 规范、准确的命名。 区分使用代码注释 /**/ (只注释代码) 与说明注释 /// ()  减少多行注释，允许的情况下与代码同行。   参考资料 #   C++注释规范是什么？\n"},{"id":40,"href":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/cpp%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/","title":"Cpp编码风格","section":"编码规则","content":"C++ 编码风格 #  这是基于 Google 发布的 C++ 编程风格指南整理的，每一项规则的详细的阐述可以参见 官方的原版指南或者 中文版。\n注意：这份指南只是提供了一份通用的编程规范，当你的项目已有自己的约定则优先遵守项目的约定！\n头文件 #  通常一个一个 .cc 对应一个 .h，但也有一些常见的例外，例如单元测试代码只有 .cc 文件和 main() 函数。\nSelf-contained 头文件 #   头文件，以 .h 结尾;  用于插入文本的文件，以 .inc 结尾; 模板或内联函数的定义不要放到 -inl.h 文件中; 不建议从 .h 中分离出 -inl.h 文件;    #define 保护 #  所有头文件都应该使用 #define 来防止头文件被多重包含, 命名格式当是: \u0026lt;PROJECT\u0026gt;_\u0026lt;PATH\u0026gt;_\u0026lt;FILE\u0026gt;_H_（路径是从项目的源代码树的根路径开始）。\n前置声明 #  尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。\n 尽量避免前置声明那些定义在其他项目中的实体;  函数：总是使用 #include; 类模板：优先使用 #include;    内联函数 #   不要内联超过 10 行的函数;  不要内联包含循环或 switch 语句的函数; 虚函数和递归函数不应该声明成内联;    #include 的路径及顺序 #   避免使用特殊的快捷目录 . 和 ..;  项目内头文件应按照项目源代码目录树结构排列; 头文件的包含顺序如下：   .cc 文件对应的头文件（优先位置） C 系统文件 C++ 系统文件 第三方库 .h 文件 本项目内 .h 文件   以空行分割以上不同类别的 #include 语句 例外：平台特定代码需要进行条件编译，这些可以放到其他的 #include 之后  作用域 #  命名空间 #   命名空间的最后(右括号)注释出名字空间的名字;  不要在命名空间 std 内声明任何东西, 包括标准库的类前置声明; 不要在头文件中使用命名空间别名除非显式标记内部命名空间使用; 禁止使用 using 指令引入其他空间的符号; 禁止使用内联命名空间;    匿名命名空间和静态变量 #   推荐、鼓励在 .cc 中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在 .h 中使用;  匿名命名空间的声明和具名的格式相同，在最后注释上 namespace;    非成员函数、静态成员函数和全局函数 #    尽量不要用裸的全局函数，使用静态成员函数或命名空间内的非成员函数; #  将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果;  非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内; 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用 命名空间; 如果必须定义非成员函数, 又只是在 .cc 文件中使用它, 可使用 匿名命名空间 或 static 链接关键字(如 static int Foo() {...})限定其作用域;    局部变量 #   在尽可能小的作用域中声明变量, 离第一次使用越近越好;  使用初始化的方式替代声明再赋值，例如：int j = g();;    静态和全局变量 #   禁止使用类的 静态储存周期 变量，不过 constexpr 变量除外;  全局变量，静态变量，静态类成员变量和函数静态变量，都必须是 POD (原生数据类型)以及 POD 类型的指针、数组和结构体; 不允许用函数返回值来初始化 POD 变量，除非该函数（比如 \u0026lsquo;\u0026lsquo;getenv()\u0026rsquo; 或 \u0026lsquo;\u0026lsquo;getpid()\u0026rsquo; ）不涉及任何全局变量; 多线程中的全局变量 (含静态成员变量) 不要使用 class 类型 (含 STL 容器);    类 #  构造函数的职责 #   不要在构造中调用虚函数;  不要在无法报出错误时进行可能失败的初始化; 如果对象需要正确的初始化，可以考虑使用明确的 Init() 方法或者工厂模式;    隐式类型转换 #   类型转换运算符和单参数构造函数都应当用 explicit 进行标记;  拷贝和移动构造函数是个例外, 不应当被标记为 explicit; 不能以一个参数进行调用的构造函数不应当加上 explicit; 接受一个 std::initializer_list 作为参数的构造函数也应当省略 explicit, 以便支持拷贝初始化;    可拷贝类型和可移动类型 #    如果类型的拷贝操作不是显而易见的，就不要设置为可拷贝; #  如果类型可拷贝，那么一定要同时给出拷贝构造函数和赋值操作的定义，反之亦然;  如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义; 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作; 如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的; 不要为任何有可能有派生类的对象提供赋值操作或者拷贝/移动构造函数 (当然也不要继承有这样的成员函数的类); 如果你的基类需要可复制属性, 请提供一个 public virtual Clone() 和一个 protected 的拷贝构造函数以供派生类实现; 如果你的类不需要拷贝 / 移动操作, 请显式地通过在 public 域中使用 = delete 或其他手段禁用;    结构体 VS 类 #   只有数据成员时使用 struct:  用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能.  成员变量直接访问而不是函数调用. 除了构造函数, 析构函数, Initialize(), Reset(), Validate() 等类似的用于设定数据成员的函数外, 不能提供其它功能的函数. 如果需要更多的函数功能, class 更适合. 如果拿不准, 就用 class. 除上述功能外其它的一概用 class; 为了和 STL 保持一致, 对于仿函数等特性可以不用 class 而是使用 struct; 注意类和结构体的成员变量使用不同的 命名规则;      继承 #  未完待续\n函数 #  参数顺序 #   输入参数在前，输出参数在后;  编写简短的函数 #   建议编写简短、凝练的函数（不硬性限制函数长度，但超过了 40 行，可以考虑下在不影响程序结构的前提下对其分割）;  引用参数 #   输入参数是值参或 const 引用, 输出参数为指针;  函数重载 #   如果打算重载一个函数，可以试试在函数名中加上参数信息，例如：用 AppendString() 和 AppendInt() 等，而不是重载多个 Append();  当重载函数是为了支持相同类型不同数量的参数时，则优先考虑使用 vector;    缺省参数 #    虚函数不允许使用缺省参数; #  也不允许每次调用缺省参数的值都不同的情况下使用缺省参数，例如：void f(int n = counter+);  函数返回类型后置语法 #   只有在常规写法不方便时使用，例如 Lambda 表达式;  来自 Google 的奇技 #  所有权与智能指针 #   当你 new 了一块内存时尽量保证在释放前自已一直都持有这个内存的指针，当其他地方需要时传递过去指针或引用，再或者是使用 std::unique_ptr;  尽量不要共享所有权，如果确实需要共享，建议使用 std::shared_ptr; 不要使用 std::auto_ptr, 推荐使用 std::unique_ptr;    Cpplint #   cpplint.py 是一个用来分析源文件, 能检查出多种风格错误的工具;  在行尾加 // NOLINT, 或在上一行加 // NOLINTNEXTLINE, 可以忽略报错;    命名约定 #  通用命名规则 #   尽可能使用描述性的命名，少用缩写（一些特定的广为人知的缩写是允许的，例如：用 i 表示迭代变量和用 T 表示模板参数）;  根据经验，如果在 Wikipedia 中列出了的缩写，则它可以考虑被使用;    文件名 #   全部用小写，可以包含 _ 或 -（更推荐 _）; C++ 文件以 .cc 结尾，头文件以 .h 结尾，专门插入文本的文件以 .inc 结尾;  不要使用与系统头文件相同的名字; 尽量让文件名更加明确，不要太笼统（例如：使用 http_server_logs.h 而不是 logs.h）;    类型命名 #   类型名称的每个单词首字母均大写, 不包含下划线;  变量命名 #   变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接;  类的成员变量以下划线结尾, 但结构体的就不用;    常量命名 #   声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 k 开头, 大小写混合;  函数命名 #   函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线;  缩写也是将其视为一个单词进行首字母大写，而不是全大写; 取值和设值函数的命名与变量一致;    名字空间命名 #   命名空间以小写字母命名;  最高级命名空间的名字取决于项目名称; 注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突;    枚举命名 #   成员的命名与 常量或者 宏一致;  枚举类型的名字与 函数命名一致;    宏命名 #   不建议使用宏，但一定要用推荐使用全大写单词间以下划线分隔的方式来命名;  命名规则的特例 #   如果你命名的实体与已有 C/C++ 实体相似, 可参考 现有命名策略;  注释 #  注释风格 #   使用 // 或 /* */, 统一就好. 但 // 更常用.  文件注释 #   不要在 .h 和 .cc 之间复制注释, 保留一份即可.  类注释 #   每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.  描述类用法的注释应当和接口定义放在一起, 描述类的操作和实现的注释应当和实现放在一起.    函数注释 #   函数声明处的注释描述函数功能;  函数的输入输出. 对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数. 函数是否分配了必须由调用者释放的空间. 参数是否可以为空指针. 是否存在函数使用上的性能隐患. 如果函数是可重入的, 其同步前提是什么? 定义处的注释描述函数实现. 如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释, 例如, 使用的编程技巧, 实现的大致步骤, 或解释如此实现的理由. 不要从 .h 文件或其他地方的函数声明处直接复制注释, 简要重述函数功能是可以的, 但重点要放在如何实现上.    变量注释 #   当变量名和类型不能够用明确表达作用, 则应当加上注释(例如特殊值, 数据成员之间的关系, 生命周期等);  如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明;    实现注释 #   巧妙或复杂的代码段前要加注释;  比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释; 对齐连续多行的注释; 如果函数参数的意义不明显, 考虑用下面的方式进行弥补: 如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破. 考虑更改函数的签名, 让某个 bool 类型的参数变为 enum 类型, 这样可以让这个参数的值表达其意义. 如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例. 这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义. 同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改. 用具名变量代替大段而复杂的嵌套表达式. 万不得已时, 才考虑在调用点用注释阐明参数的意义. 不要描述显而易见的现象;    标点, 拼写和语法 #   注意标点, 拼写和语法;  TODO 注释 #   TODO 注释要使用全大写的字符串, 在随后的圆括号里写上你的名字, 邮件地址, bug ID 或其它身份标识和这一 TODO 相关的 issue;  如果加 TODO 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间;    弃用注释 #   可以写上包含全大写的 DEPRECATED 的注释, 以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行;  仅仅标记接口为 DEPRECATED 并不会让大家不约而同地弃用, 您还得亲自主动修正调用点;\n===== 格式 =====    行长度 #   每一行代码字符数不超过 80;  包含长路径的 #include 语句可以超出80列; 头文件卫士无视该原则;    非 ASCII 字符 #   尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码;  空格还是制表位 #   只使用空格, 每次缩进 2 个空格;  设置编辑器将制表符转为空格;    函数声明与定义 #   返回类型和函数名在同一行;  参数尽量放在同一行, 如果放不下就对形参分行, 分行方式与 函数调用 一致; 使用好的参数名. 只有在参数未被使用或者其用途非常明显时, 才能省略参数名. 如果返回类型和函数名在一行放不下, 分行. 如果返回类型与函数声明或定义分行了, 不要缩进. 左圆括号总是和函数名在同一行. 函数名和左圆括号间永远没有空格. 圆括号与参数间没有空格. 左大括号总在最后一个参数同一行的末尾处, 不另起新行. 右大括号总是单独位于函数最后一行, 或者与左大括号同一行. 右圆括号和左大括号间总是有一个空格. 所有形参应尽可能对齐. 缺省缩进为 2 个空格. 换行后的参数保持 4 个空格的缩进. 未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来; 属性, 和展开为属性的宏, 写在函数声明或定义的最前面, 即返回类型之前;    Lambda 表达式 #   对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开;  函数调用 #    要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里; #  如果参数本身是略复杂的表达式，且降低了可读性，那么可以直接创建临时变量描述该表达式并传递给函数;  如果参数本身就有一定的结构, 可以酌情地按其结构来决定参数格式;    列表初始化格式 #   平时怎么格式化函数调用, 就怎么格式化 列表初始化.  条件语句 #   关键字 if 和 else 另起一行, else 与 if 的 } 同一行;  if 和 ( 间都有个空格, ) 和 { 之间也要有个空格; 简短的条件语句允许写在同一行，当存在 else 分支时则不允许; 当语句中某个 if-else 分支使用了大括号时, 其它分支也必须使用;    循环和开关选择语句 #   switch 应该总是包含一个 default 匹配, 如果 default 应该永远执行不到, 简单的加条 assert; 空循环体应使用 {} 或 continue, 而不是一个简单的分号;  指针和引用表达式 #   在访问成员时, 句点或箭头前后没有空格;  指针操作符 * 或 \u0026amp; 后没有空格;    布尔表达式 #   断行时逻辑操作符(\u0026amp;\u0026amp;, ||)总位于行尾;  函数返回值 #   不要在 return 表达式里加上非必须的圆括号(类似return (value)这种形式);  可以用圆括号把复杂表达式圈起来, 改善可读性;    变量及数组初始化 #   用 =, () 和 {} 均可;  列表初始化({})不允许整型类型的四舍五入;    预处理指令 #   预处理指令不要缩进, 从行首开始, 即使位于缩进代码块中, 也应从行首开始;  类格式 #   访问控制块的声明依次序是 public:, protected:, private:, 每个都缩进 1 个空格;  所有基类名应在 80 列限制下尽量与子类名放在同一行; 除第一个关键词 (一般是 public) 外, 其他关键词前要空一行,这些关键词后不要保留空行.. 如果类比较小的话也可以不空    构造函数初始值列表 #   构造函数初始化列表放在同一行或按四格缩进并排多行;  如果不能放在同一行, 必须置于冒号后, 并缩进 4 个空格. 如果初始化列表需要置于多行, 将每一个成员放在单独的一行并逐行对齐. } 可以和 { 放在同一行, 如果这样做合适的话.    命名空间格式化 #   命名空间内容不要增加额外的缩进层次;  声明嵌套命名空间时, 每个命名空间都独立成行;    水平留白 #  通用 #   { 前总是有空格.  ; 前不加空格. 继承与初始化列表中的 : 前后恒有空格. 对于单行函数的实现, 在大括号内加上空格, 即 int fun(int v) { return v; }. 函数的 {} 里面是空的话, 不加空格. ( 的后面和 ) 的前面都不加空格.    循环和条件语句 #   if 条件语句和循环语句关键字后均有空格.  else 前后都有空格. for 循环里 ; 后有空格. switch case 的 : 前无空格, 如果 : 后面有代码, 则 : 后面加个空格.    操作符 #   赋值运算符前后总是有空格.  其它二元操作符也前后总有空格, 不过对于表达式的子式可以不加空格. 在参数和一元操作符之间不加空格.    模板和转换 #   \u0026lt; \u0026gt;(尖括号) 不与空格紧邻, \u0026lt; 前没有空格, \u0026gt; 和 ( 之间也没有.  垂直留白 #   两个函数定义之间的空行不要超过 2 行;  函数体首尾不要留空行; 函数体中也不要随意添加空行; 在多重 if-else 块里加空行或许有点可读性;    规则特例 #  现有不合规范的代码 #   对于现有不符合既定编程风格的代码，优先与代码原有风格保持一致;  Windows 代码 #  这一部分可以参考指南的原文档。\n参考资料 #   Google C++ Style Guide\nGoogle 开源项目风格指南(中文版)\n"},{"id":41,"href":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99/%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","title":"工程目录结构","section":"编码规则","content":"工程目录结构 #  目前这份结构只考虑了 C/C++ 的工程\nproject_root |- 3rdparty |- builds(platforms) |- cmake |- bin |- lib |- include |- project_name |- module_1 |- module_2 |- config |- readme.md |- data |- test |- sample |- scripts |- doc   readme.md: 自述文件。 3rdparty: 第三方库的源代码。以子项目(git submodule)的形式存在，如果没有则不需要这文件夹。 data: 存放测试数据，可以没有。 test: 存放单元测试代码，其内部层级结构与 src 一致。 sample: 存放示例代码。 doc: 存放文档（如果文档全上 wiki 这个是不是可以不要？）。 builds(platforms): 构建系统，里面根据不同平台再划分一级目录，分别存放对应的 构建脚本(cmake、makefile 等)。 cmake: 存放 .cmake 文件，不使用 cmake 可以不要这个目录 project_name: 总源码目录，内部分模块组织。   * 每个模块放在同名的文件夹下，模块内部存放该模块的主要功能逻辑代码，但不可以出现模块嵌套的情况。 * 包含内部头文件时，要从 ''project_name'' 开拼写完整路径，防止头文件名称冲突，遵循 google c++ 编码规范。 * ''config'': 存放配置文件模板。 * ''scripts'': 存放脚本文件，如发布脚本。 * ''include'': 第三方库的头文件。 * ''lib'': 三/二方库的库文件。 * ''bin'': 工程的输出目录。  "},{"id":42,"href":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E8%AF%91%E6%9C%BA%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95/","title":"编译机环境管理方法","section":"技术归纳","content":"编译机环境管理方法 #  以用户的方式管理 #  说明 #   创建一个compiler用户  这个用户用于系统默认编译器的的编译 该用户的家目录下存放所有代码 所有添加的其他编译用户都处于compiler中户组（给compiler设置 SGID 可以使其下面的文件夹都默认处于compiler组里） 该用户家目录的所有代码都要给组用户写权限   创建用户，以 NDK 为例，%%android-ndk-r13b-linux-x86_64 对应的用户名 android-ndk-r13 将编译器安装在对应的用户家目录中 将需要的环境变量配置在用户的.bash_prefile中 配置umask，给组与用户同样的权限  演示配置 android-ndk-r13 用户 #  # adduser android-ndk-r13 -g compiler # echo \u0026quot;umask 002\u0026quot; \u0026gt;\u0026gt; /home/android-ndk-r13/.bashrc # su - android-ndk-r13 # unzip android-ndk-r13b-linux-x86_64.zip  配置环境变量 #  在~/bash_prefile中添加下面\nexport NDKROOT=/home/android-ndk-r13/android-ndk-r13b export PATH=$NDKROOT:$PATH  INSTALLATION_PATH=/home/output/android-ndk-r13 export prefix=$INSTALLATION_PATH  export ANDROID_HOME=~/android-ndk-r13b export TOOLCHAIN=$ANDROID_HOME/android-toolchain export CROSS_SYSROOT=$TOOLCHAIN/sysroot export PATH=$TOOLCHAIN/bin:$PATH export TOOL=arm-linux-androideabi export CC=$TOOLCHAIN/bin/${TOOL}-gcc export CXX=$TOOLCHAIN/bin/${TOOL}-g++ export LINK=${CXX} export LD=$TOOLCHAIN/bin/${TOOL}-ld export AR=$TOOLCHAIN/bin/${TOOL}-ar export RANLIB=$TOOLCHAIN/bin/${TOOL}-ranlib export STRIP=$TOOLCHAIN/bin/${TOOL}-strip export ARCH_FLAGS=\u0026#34;-mthumb\u0026#34; export ARCH_LINK= export CFLAGS=\u0026#34;${ARCH_FLAGS}-fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64\u0026#34; export CXXFLAGS=\u0026#34;${CFLAGS}-frtti -fexceptions\u0026#34; export LDFLAGS=\u0026#34;${ARCH_LINK}\u0026#34; 参考资料 #   linux下如何实现不同的用户对同一文件都有写权限\nLinux系统之文件的SUID、SGID、Sticky权限说明\n"},{"id":43,"href":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/markdown/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","title":"基本语法","section":"Markdown","content":"\u0026lt;markdown\u0026gt; # Markdown 语法指南\n Markdown是为网络书写者而生的方便“text-to-HTML”工具，它允许人们用一种易读易写的纯文本格式进行书写，然后将其转化成XHTML（或HTML）。\n \u0026gt;\n Markdown 的特点是“易读易写”，其中可读性是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。\n \u0026gt;\n Markdown 语法的目标是：成为一种适用于网络的书写语言。\n \u0026gt;\n Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。\n—— John Gruber\n ## 简介\n## 文字的基本格式 ### 倾斜 前后各一个 `*` （星号）或 `_` （下划线符）包围的文本是倾斜文本。 `*倾斜*` *倾斜* `_倾斜_` _倾斜_ 但不能`*` 和 `_` 一样一个的混用，像这样 `*倾斜_`\n### 加粗 前后各两个 `*` （星号）或 `_` （下划线符）包围的文本是倾斜文本。 `加粗` 加粗 `加粗` 加粗\n### 倾斜并加粗 `*倾斜并加粗*` *倾斜并加粗* `_倾斜并加粗_` _倾斜并加粗_\n### 删除线 `~~删除文本~~` ~~删除文本~~\n### 高亮 `==标记文本==` \u0026lt;mark\u0026gt;标记文本\u0026lt;/mark\u0026gt; **注：该功能不一定所有的 Markdown 都支持，可以使用 html 的 `\u0026lt;mark\u0026gt;` **\n### 引用 #### 单次引用 `\u0026gt; 单次引用`\n 单次引用\n #### 嵌套引用 ```\n 嵌套引用1\n 嵌套引用2\n 嵌套引用3\n 嵌套引用2\n 嵌套引用1\n ```\n 嵌套引用1\n 嵌套引用2\n 嵌套引用3\n 嵌套引用2\n 嵌套引用1\n ### 标题 `#` + 空格 可以生成一级标题，也就是对应 html 里的 `\u0026lt;h1\u0026gt;` 标签，几个 `#` 就对应的几级标题，大部分的 Markdown 最多支持6级标题。 ``` #### 四级标题\n##### 五级标题\n###### 六级标题 ``` #### 四级标题\n##### 五级标题\n###### 六级标题\n### 列表 Markdown列表有有序列表、无序列表、任务列表、嵌套列表四种。列表可以嵌套成多级列表。 #### 有序列表 ` 1. 注意，注意的前面有一个空格` 1. 注意，注意前面有一个空格\n#### 无序列表 `+`、`-`、`*`都可以用来标记无序列表 + 这个用的`+` - 这个用的`-` * 这个用的`*`\n#### 任务列表 ``` - [x] 已完成任务 - [ ] 未完成任务 ``` - [x] 已完成任务 - [ ] 未完成任务\n#### 嵌套列表 列表嵌套只需在子列表中的选项缩进四个空格即可 ``` 1. 任务一：\n - 任务一嵌套的第一个元素 - 任务一嵌套的第二个元素  2. 任务二：\n - 任务二嵌套的第一个元素 - 任务二嵌套的第二个元素  ``` 1. 任务一：\n - 任务一嵌套的第一个元素 - 任务一嵌套的第二个元素  2. 任务二：\n - 任务二嵌套的第一个元素 - 任务二嵌套的第二个元素  ## 链接 ### 网页链接 `[要显示的文字](链接的地址)`，例： ``` [百度]( www.baidu.com) |- 这里有填写前面要显示的文字 []( www.baidu.com) |- 这里没有填写前面要显示的文字 ``` [百度]( www.baidu.com) |- 这里有填写前面要显示的文字 []( www.baidu.com) |- 这里没有填写前面要显示的文字\n### 图片 `![注释，可有可无](链接的地址)`，例： ``` ![百度的logo]( https://bkimg.cdn.bcebos.com/pic/b8014a90f603738da97755563251a751f81986184626?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2UyNzI=,g_7,xp_5,yp_5/format,f_auto) ``` ![百度的logo]( https://bkimg.cdn.bcebos.com/pic/b8014a90f603738da97755563251a751f81986184626?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2UyNzI=,g_7,xp_5,yp_5/format,f_auto)\n### 自动链接/邮箱 自动链接直接用一对尖括号包围即可，`\u0026lt; https://wiki2.codeqs.com\u0026gt;`，显示\u0026lt; https://wiki2.codeqs.com\u0026gt;\n## 代码 ### 行内代码 使用 \\` (键盘左上角1左边的那个键，不是单引号)包起来的部分 \\`代码片段\\` 显示 `代码片段`\n### 代码块 使用 3 个 \\` (同上)包起来的部分 \\`\\`\\` 代码语言 代码块 \\`\\`\\` ``` c #include \u0026lt;iostream\u0026gt; int main(void) {\n std::cout \u0026lt;\u0026lt; \u0026quot;hello world\u0026quot; \u0026lt;\u0026lt; std::endl; return 0;  } ```\n## 段落 如果是中文书写习惯，每一段的开头，都应该空4个英文字符的宽度。一般在word里，在段首可以直接按`Tab`键实现，但在 Markdown 中，这并不起作用。这就需要使用 html 来实现。\n### 缩进 使用 html 的空格表示方法 ` `, ` `, ` `\n### 对齐 使用 html 的对齐方法 ` \u0026lt;p align=\u0026ldquo;center\u0026rdquo;\u0026gt;`, `\u0026lt;p align=\u0026ldquo;right\u0026rdquo;\u0026gt;`, ` \u0026lt;p align=\u0026ldquo;left\u0026rdquo;\u0026gt;`\n### 换行 在行尾输入两个空格即可（敲击两下空格键）。\n### 分割线 在标准 Markdown 中，分割线一般由连续的 3 个同样的`-`、`+`、`*`组成，只需这三个符号在同一行且没有字符（除了空格）即可，符号之间有没有空格不影响分割线的生成。如`\u0026ndash; -`、`+ + +`、`***`都可以。\n## 表格 基本表格 基本的表格方法如下： ```\n         Items Prices   :\u0026ndash;: : \u0026ndash; :   Apple 20$   Banana 25$    ``` 第一行：表头，两个符号|间的内容是标题；\n第二行：可选，设置表中内容的对齐方式，默认是靠近显示，如下：\n`: \u0026mdash; :` 设置内容水平居中对齐；\n`: \u0026mdash; ` 设置内容左对齐；\n` \u0026mdash; :` 设置内容右对齐；\n## 脚注 ``` markdown 脚注[^1] [^1]: 这里是脚注 ``` 脚注[^1] [^1]: 这里是脚注\n## 锚点跳转 有这么一种情况：浏览一个很长的文章时，可能只对其中几个章节感兴趣时，需要直接跳转到该章节，这时就需要锚点。\n锚点是是网页制作中超级链接的一种，又叫命名锚记。使用命名锚记可以在文档中设置标记，这些标记通常放在文档的特定主题处或顶部。然后可以创建到这些命名锚记的链接，这些链接可快速将访问者带到指定位置4。\n锚点跳转要注意首先要注意以下两点：\n1. 锚点的标识名称，可使用任意字符，使用锚点跳转； 2. 锚点生成的链接，可以是页内跳转，也可以生成目录； 3. 锚点只对`#`标注的标题生成锚点链接； 4. 锚点的基本格式是：`[跳转标题](#跳转标题)`，注意`()`里的`#`与后面的内容无空格，且只有一个`#`，该符号与正文里的多级标题无关（不管是几级标题，只需要一个`#URL`）； 5. 非英文的锚点字符，在单击跳转时，在浏览器的URL中会按照规则进行编码和解码；\n在使用时还需要记住以下几个问题：\n* 任意 1-6 个#标注的标题都可设置为同名的锚点链接 ``` [标题1](#标题1) [标题2](#标题2) [标题3](#标题3) # 标题1 ## 标题2 ### 标题3 ```\n* 大写字母要转换成小写 ``` [Github标题](#github标题) ### Github标题 ``` * 多单词锚点的空格用`-`代替 ``` [Github Heading](#github-heading) ### Github Heading ``` * 多级序号需要去除`.` ``` [2.3. Github Heading](#23-github-heading) ### 2.3. Github Heading ```\n\u0026lt;/markdown\u0026gt;\n"},{"id":44,"href":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E8%AF%AD%E8%A8%80/shell/shell%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","title":"Shell的基础语法","section":"Shell","content":"Shell 基础语法 #  注释 #  单行注释 #  使用 #\n# echo \u0026#34;hello\u0026#34; 多行注释 #  方法一 #   : \u0026lt;\u0026lt; !  这是注释1  这是注释2  这是注释3  ! 方法二 #   :\u0026#39; 这是注释1 这是注释2 这是注释3 \u0026#39; 方法三 #   : \u0026lt;\u0026lt; 字符 #这里的字符可以是数字或者是字符都可以  这是注释1  这是注释2  这是注释3  字符 #这里的字符要和一开始的一样 方法四 #   if false; then  这是注释1  这是注释2  这是注释3  fi 方法五 #   ((0))\u0026amp;\u0026amp;{  这是注释1  这是注释2  这是注释3  } 参考资料 #   shell中的单行注释和多行注释\n"},{"id":45,"href":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/c_cpp/errno%E9%94%99%E8%AF%AF%E7%A0%81%E8%AF%B4%E6%98%8E/","title":"Errno错误码说明","section":"C/C++","content":"\u0026lt;markdown\u0026gt; # errno 错误码说明 关于 errno 的相关定义都在头文件 `/usr/include/asm/errno.h` 中，下面是从文件中拷出来方便查询 ```\n #define EPERM 1 /* Operation not permitted */操作不允许  　#define ENOENT 2 /* No such file or directory */文件/路径不存在\n　#define ESRCH 3 /* No such process */进程不存在\n　#define EINTR 4 /* Interrupted system call */中断的系统调用\n　#define EIO 5 /* I/O error */I/O错误\n　#define ENXIO 6 /* No such device or address */设备/地址不存在\n　#define E2BIG 7 /* Arg list too long */参数列表过长\n　#define ENOEXEC 8 /* Exec format error */执行格式错误\n　#define EBADF 9 /* Bad file number */错误文件编号\n　#define ECHILD 10 /* No child processes */子进程不存在\n　#define EAGAIN 11 /* Try again */重试\n　#define ENOMEM 12 /* Out of memory */内存不足\n　#define EACCES 13 /* Permission denied */无权限\n　#define EFAULT 14 /* Bad address */地址错误\n　#define ENOTBLK 15 /* Block device required */需要块设备\n　#define EBUSY 16 /* Device or resource busy */设备或资源忙\n　#define EEXIST 17 /* File exists */文件已存在\n　#define EXDEV 18 /* Cross-device link */跨设备链路\n　#define ENODEV 19 /* No such device */设备不存在\n　#define ENOTDIR 20 /* Not a directory */路径不存在\n　#define EISDIR 21 /* Is a directory */是路径\n　#define EINVAL 22 /* Invalid argument */无效参数\n　#define ENFILE 23 /* File table overflow */文件表溢出\n　#define EMFILE 24 /* Too many open files */打开的文件过多\n　#define ENOTTY 25 /* Not a typewriter */非打字机\n　#define ETXTBSY 26 /* Text file busy */文本文件忙\n　#define EFBIG 27 /* File too large */文件太大\n　#define ENOSPC 28 /* No space left on device */设备无空间\n　#define ESPIPE 29 /* Illegal seek */非法查询\n　#define EROFS 30 /* Read-only file system */只读文件系统\n　#define EMLINK 31 /* Too many links */链接太多\n　#define EPIPE 32 /* Broken pipe */管道破裂\n　#define EDOM 33 /* Math argument out of domain of func */参数超出函数域\n　#define ERANGE 34 /* Math result not representable */结果无法表示\n　#define EDEADLK 35 /* Resource deadlock would occur */资源将发生死锁\n　#define ENAMETOOLONG 36 /* File name too long */文件名太长\n　#define ENOLCK 37 /* No record locks available */没有可用的记录锁\n　#define ENOSYS 38 /* Function not implemented */函数未实现\n　#define ENOTEMPTY 39 /* Directory not empty */目录非空\n　#define ELOOP 40 /* Too many symbolic links encountered */遇到太多符号链接\n　#define EWOULDBLOCK EAGAIN /* Operation would block */操作会阻塞\n　#define ENOMSG 42 /* No message of desired type */没有符合需求类型的消息\n　#define EIDRM 43 /* Identifier removed */标识符已删除\n　#define ECHRNG 44 /* Channel number out of range */通道编号超出范围\n　#define EL2NSYNC 45 /* Level 2 not synchronized */level2不同步\n　#define EL3HLT 46 /* Level 3 halted */3级停止\n　#define EL3RST 47 /* Level 3 reset */3级重置\n　#define ELNRNG 48 /* Link number out of range */链接编号超出范围\n　#define EUNATCH 49 /* Protocol driver not attached */协议驱动程序没有连接\n　#define ENOCSI 50 /* No CSI structure available */没有可用的CSI结构\n　#define EL2HLT 51 /* Level 2 halted */2级停止\n　#define EBADE 52 /* Invalid exchange */无效交换\n　#define EBADR 53 /* Invalid request descriptor */无效请求描述\n　#define EXFULL 54 /* Exchange full */交换完全\n　#define ENOANO 55 /* No anode */无阳极\n　#define EBADRQC 56 /* Invalid request code */无效请求码\n　#define EBADSLT 57 /* Invalid slot */无效插槽\n　#define EDEADLOCK EDEADLK\n　#define EBFONT 59 /* Bad font file format */错误的字体文件格式\n　#define ENOSTR 60 /* Device not a stream */设备不是流\n　#define ENODATA 61 /* No data available */无数据\n　#define ETIME 62 /* Timer expired */计时器到期\n　#define ENOSR 63 /* Out of streams resources */流资源不足\n　#define ENONET 64 /* Machine is not on the network */机器不在网络上\n　#define ENOPKG 65 /* Package not installed */包未安装\n　#define EREMOTE 66 /* Object is remote */对象是远程\n　#define ENOLINK 67 /* Link has been severed */链接正在服务中\n　#define EADV 68 /* Advertise error */广告错误\n　#define ESRMNT 69 /* Srmount error */？\n　#define ECOMM 70 /* Communication error on send */发送过程中通讯错误\n　#define EPROTO 71 /* Protocol error */协议错误\n　#define EMULTIHOP 72 /* Multihop attempted */多跳尝试\n　#define EDOTDOT 73 /* RFS specific error */RFS特定错误\n　#define EBADMSG 74 /* Not a data message */不是数据类型消息\n　#define EOVERFLOW 75 /* Value too large for defined data type */对指定的数据类型来说值太大\n　#define ENOTUNIQ 76 /* Name not unique on network */网络上名字不唯一\n　#define EBADFD 77 /* File descriptor in bad state */文件描述符状态错误\n　#define EREMCHG 78 /* Remote address changed */远程地址改变\n　#define ELIBACC 79 /* Can not access a needed shared library */无法访问需要的共享库\n　#define ELIBBAD 80 /* Accessing a corrupted shared library */访问损坏的共享库\n　#define ELIBSCN 81 /* .lib section in a.out corrupted */库部分在a.out损坏\n　#define ELIBMAX 82 /* Attempting to link in too many shared libraries */试图链接太多的共享库\n　#define ELIBEXEC 83 /* Cannot exec a shared library directly */不能直接运行共享库\n　#define EILSEQ 84 /* Illegal byte sequence */非法字节序\n　#define ERESTART 85 /* Interrupted system call should be restarted */应重新启动被中断的系统调用\n　#define ESTRPIPE 86 /* Streams pipe error */流管错误\n　#define EUSERS 87 /* Too many users */用户太多\n　#define ENOTSOCK 88 /* Socket operation on non-socket */在非套接字上进行套接字操作\n　#define EDESTADDRREQ 89 /* Destination address required */需要目的地址\n　#define EMSGSIZE 90 /* Message too long */消息太长\n　#define EPROTOTYPE 91 /* Protocol wrong type for socket */错误协议类型\n　#define ENOPROTOOPT 92 /* Protocol not available */协议不可用\n　#define EPROTONOSUPPORT 93 /* Protocol not supported */不支持协议\n　#define ESOCKTNOSUPPORT 94 /* Socket type not supported */不支持套接字类型\n　#define EOPNOTSUPP 95 /* Operation not supported on transport endpoint */操作上不支持传输端点\n　#define EPFNOSUPPORT 96 /* Protocol family not supported */不支持协议族\n　#define EAFNOSUPPORT 97 /* Address family not supported by protocol */协议不支持地址群\n　#define EADDRINUSE 98 /* Address already in use */地址已被使用\n　#define EADDRNOTAVAIL 99 /* Cannot assign requested address */无法分配请求的地址\n　#define ENETDOWN 100 /* Network is down */网络已关闭\n　#define ENETUNREACH 101 /* Network is unreachable */网络不可达\n　#define ENETRESET 102 /* Network dropped connection because of reset */网络由于复位断开连接\n　#define ECONNABORTED 103 /* Software caused connection abort */软件导致连接终止\n　#define ECONNRESET 104 /* Connection reset by peer */连接被对方复位\n　#define ENOBUFS 105 /* No buffer space available */没有可用的缓存空间\n　#define EISCONN 106 /* Transport endpoint is already connected */传输端点已连接\n　#define ENOTCONN 107 /* Transport endpoint is not connected */传输端点未连接\n　#define ESHUTDOWN 108 /* Cannot send after transport endpoint shutdown */传输端点关闭后不能在发送\n　#define ETOOMANYREFS 109 /* Too many references: cannot splice */太多的引用：无法接合\n　#define ETIMEDOUT 110 /* Connection timed out */连接超时\n　#define ECONNREFUSED 111 /* Connection refused */连接被拒绝\n　#define EHOSTDOWN 112 /* Host is down */主机已关闭\n　#define EHOSTUNREACH 113 /* No route to host */无法路由到主机\n　#define EALREADY 114 /* Operation already in progress */操作已在进程中\n　#define EINPROGRESS 115 /* Operation now in progress */进程中正在进行的操作\n　#define ESTALE 116 /* Stale NFS file handle */\n　#define EUCLEAN 117 /* Structure needs cleaning */\n　#define ENOTNAM 118 /* Not a XENIX named type file */\n　#define ENAVAIL 119 /* No XENIX semaphores available */\n　#define EISNAM 120 /* Is a named type file */\n　#define EREMOTEIO 121 /* Remote I/O error */\n　#define EDQUOT 122 /* Quota exceeded */\n　#define ENOMEDIUM 123 /* No medium found */\n　#define EMEDIUMTYPE 124 /* Wrong medium type */ ```\n\u0026lt;/markdown\u0026gt;\n"},{"id":46,"href":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/c_cpp/gnu%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%8D%A2%E5%90%8D%E8%A7%84%E5%88%99/","title":"Gnu编译器的换名规则","section":"C/C++","content":"GNU C++ 编译器的换名规则 #  全局变量 #  不做任何修改\n全局函数 #  以_Z开头，然后是函数名字符的个数，接着是函数名，最后是函数参数的别名。\n类或命名空间中的变量或函数 #  以_ZN开头，然后是变量或函数所在名字空间或类名字的字符长度，然后接着的是真正的名字空间或类名，然后是变量或函数名的长度和变量或函数名，后面紧跟字母E，最后如果是函数的话则跟参数别名，如果是变量则什么都不用加。\n构造函数和析构函数 #  以_ZN开头，然后是构造函数所在名字空间和类名字的字符长度，然后接着的是真正的名字空间或类名，然后构造函数接C1或者C2，析构函数接D1或者D2，然后加上字母E，最后接函数参数别名结束。\n函数的参数 #  是基本类型时 #     参数类型 参数别名     void v   wchar_t w   bool b   char c   signed char a   unsigned char h   short s   unsigned short t   int i   unsigned int j   long l   unsigned long m   long long或__int64 x   unsigned long long或unsigned __int64 y   __int128 n   unsigned __int128 o   float f   double d   long double或__float80 e   __float128 g    是类或结构体时 #  在类或者结构体名字前加上类或结构体名的字符长度\n例如，全局函数int structure_func(int i, struct test s, double d)，其经过符号改编后，函数名变成了_Z14structure_funci4testd。\n是指针（*）时 #  含有指针时，该参数的别名是P（大写）加上该指针指向的参数类型的别名。当参数为指针的指针时，该参数的别名是PP加上所指向的参数类型的别名，以此类推。\n是一维数组时 #  和参数是指针的处理方式一样，也是P加上作为参数的数组其元素类型的别名。\n是多维数组时 #  第一维可以看做是指针，其它维则看做是数组。\n当函数参数中含有多维数组时，以P（代表数组的第一维）开始，后面接A加上各维数组的长度，以_间隔，最后以下划线加数组元素类型的别名结束。\n例如，全局函数void multi_array_func(int a[10][10][20][30])，其经过符号改编后，函数名变成了_Z16multi_array_funcPA10_A20_A30_i。\n含有const修饰符时 #  以K（大写）开始，后面接修饰参数类型的别名\n是引用（\u0026amp;）时 #  以R（大写）开始，后面加上该引用所引用的变量类型的别名。\n例如，全局函数void ref_const_func(const int \u0026amp;i)，其经过符号改编后，函数名变成了_Z14ref_const_funcRKi。\n是别的命名空间中的类或结构体 #  该参数的别名是N（大写），加上空间名的长度，再加上空间名，接着是类或结构名的长度和类或结构的名字，最后以E（大写）结束。\n总结 #   除了全局变量不用做改编之外，其它所需要改编符号的时候，都是以_Z开始；  若想表示某个符号是在命名空间或类中的，要以N开始，以E结束；   所有的名字空间名、类名、函数名或变量名，改编的时候都是名字所包含的字符数加上真正的名字；  所有的名字按照从外层到里层的顺序进行改编； 如果是函数的话，所有的参数按照前后出现的顺序进行改编。    参考资料 #   GNU C++的符号改编机制介绍\n"},{"id":47,"href":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/c_cpp/%E9%94%99%E8%AF%AF%E5%BD%92%E7%BA%B3/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/","title":"编译相关","section":"错误归纳","content":"C++ 编译相关的错误整理 #  undefined reference to XXX #  这是非常常见的一个问题，原因差不多有以下三点：\n 编译器找不到定义了XXX的文件;  定义了XXX的文件，由于函数修饰的原因里面没有想要的XXX符号; 找到了想要的符号，但是该符号是隐藏属性，不能链接使用;\n详细的解释与解决方法请查看参考资料。    参考资料 #   \u0026ldquo;undefined reference to XXX\u0026quot;问题总结\nexpected primary-expression before xx token #  这个 xx 指的是一半都是运算符，比如 ++，— 等\n示例 #  \u0026rsquo;\u0026rsquo; expected primary-expression before \u0026lsquo;)\u0026rsquo; token\u0026rsquo;'\n原因 #  把类型(type)当成变量来用了(variable)\n参考资料 #   expected primary-expression before xx token 错误处理\nexpected unqualified-id before \u0026lsquo;(\u0026rsquo; token #  原因 #  头文件的引用顺序引起的，只需要调整引用该头文件的其他文件在报错的 .cpp 文件中的引用顺序即可，一般将该文件或者引用该头文件的头文件置于自定义头文件的前面。\n参考资料 #   linux下编译复数类型引发的错误：expected unqualified-id before \u0026lsquo;(\u0026rsquo; token\n[]expected unqualified-id before \u0026lsquo;(\u0026rsquo; token]\n===== DSO missing from command line ===== 出现的场景是：\n 我们有一个shared libA中，定义了函数foo() 另一个静态库libB显示地链接了libA 一个可执行文件bin_c显示地链接了libA\n=== 原因 === 不会自动递归链接动态库，需要手动指明。\n==== 参考资料 ==== [[https://segmentfault.com/a/1190000002462705?utm_source=tag-newest|DSO missing from command line 原因及解决办法]( https://blog.csdn.net/haidonglin/article/details/78810264)  error: explicit qualification in declaration of xxx #  示例 #  namespace threedog { void threedog::func(int i); }  上面这种写法编译时就会报错误信息 \u0026lsquo;\u0026rsquo;error: explicit qualification in declaration of \u0026rsquo;threedog\u0026rsquo; '\u0026rsquo;\n原因 #  已经在命名空间中，却又在声明中加上了限定符。去掉错误信息中提示的限定符即可。\n参考资料 #   C++编译错误 ：error: explicit qualification in declaration of xxx\n"},{"id":48,"href":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/python/%E5%86%85%E7%BD%AE%E9%94%99%E8%AF%AF%E9%9B%86%E5%90%88/","title":"内置错误集合","section":"Python","content":"Python 内置错误集合 #  BaseException—\u0026gt;所有异常的基类 #  *SystemExit: 解释器请求退出 \\\\ *KeyboardInterrupt: 用户中断执行(输入) \\\\ *GeneratorExit: 生成器发生异常通知退出 \\\\  Exception—\u0026gt;常规异常的基类 #  *StopIteration: 迭代器没有更多的值\\\\ *StopAsyncIteration: 必须通过异步迭步器''__anext__()''方法引发以停止迭代 \\\\  ArithmeticError—\u0026gt;各种运算错误异常的基类 #  *FloatingPointError: 浮点计算错误 \\\\ *OverflowError: 数值运算结果太大无法表示 \\\\ *ZeroDivisionError: 除法或模运算的第二个自变量为零 \\\\ *AssertionError: assert(断言)语句失败时\\\\ *AttributeError: 属性引用或赋值失败\\\\ *BufferError: 无法执行与缓存区相关的操作\\\\ *EOFError: 当input()函数达到文件结束条件(EOF)而不读取任何数据时  ImportError—\u0026gt;导入模块或对象失败 #  *ModuleNotFoundError: 无法找到要导入的模块  LookupError—\u0026gt;映射或序列上使用的键或索引无效的基类 #  *IndexError: 序列下标超出范围\\\\ *KeyError: 在现有键集中找不到映射(字典)的键\\\\ *MemoryError: 操作内存不足  NameError—\u0026gt;未声明/初始化对象 #  *UnboundLocalError: 访问未初始化的本地变量  OSError—\u0026gt;操作系统错误 #  *BlockingIOError: 操作将阻塞对象设置为非阻塞操作\\\\ *ChildProcessError: 子进程上的操作失败  ConnectionError—\u0026gt;与连接相关的异常的基类 #  *BrokenPipeError: 另一端关闭时尝试写入管道或试图在已关闭写入的套接字上写入\\\\ *ConnectionAbortedError: 等方终止连接尝试\\\\ *ConnectionRefusedError: 等端拒绝连接尝试\\\\ *ConnectionResetError: 等方重置连接\\\\ *FileExistsError: 尝试创建已经存在的文件或目录\\\\ *FileNotFoundError: 请求文件或目录但不存在\\\\ *InterruptedError: 系统调用被传入信号中断\\\\ *IsADirectoryError: 在目录上请求文件操作 (例如os.remove())\\\\ *NotADirectoryError: 在非目录上请求目录操作(例如os.listdir())\\\\ *PermissionError: 尝试在没有足够访问权限（例如文件系统权限）的情况下运行操作\\\\ *ProcessLookupError: 给定的进程不存在\\\\ *TimeoutError: 系统功能在系统级别超时\\\\ *ReferenceError: weakref.proxy()函数创建的弱引用试图访问已经垃圾回收了的对象  RuntimeError—\u0026gt;检测到不属于任何其他类别的错误时 #  *NotImplementedError: 在用户定义的基类中，抽象方法要求派生类重写该方法或者正在开发的类指示仍然需要添加实际实现\\\\ *RecursionError: 解释器检测到超出最大递归深度  SyntaxError—\u0026gt;语法错误的基类 #  IndentationError—\u0026gt;缩进错误 #  *TabError: Tab和空格混用出现错误\\\\ *SystemError: 解释器发现内部错误时\\\\ *TypeError: 将操作或功能应用于不合适类型的对象  ValueError—\u0026gt;操作或函数接收到类型正确但值不合适的参数 #  UnicodeError—\u0026gt;发生与Unicode相关的编码或解码错误 #  *UnicodeDecodeError: Unicode解码错误\\\\ *UnicodeEncodeError: Unicode编码错误\\\\ *UnicodeTranslateError: Unicode转码错误  Warning—\u0026gt;警告类别的基类 #  *DeprecationWarning: 有关已弃用功能的警告的基类\\\\ *PendingDeprecationWarning: 有关不推荐使用功能的警告的基类\\\\ *RuntimeWarning: 有关可疑运行时行为的基类\\\\ *SyntaxWarning: 有关可疑语法的基类 *UserWarning: 用户代码生成的警告的基类\\\\ *FutureWarning: 有关已弃用功能的警告的基类\\\\ *ImportWarning: 用于警告有关模块导入中可能错误的警告的基类\\\\ *UnicodeWarning: 与Unicode相关的警告的基类\\\\ *BytesWarning: 与bytes和bytearray有关的警告的基类\\\\ *ResourceWarning: 与资源使用相关的警告的基类  参考资料 #   绝对干货！一张图整理了 Python 所有内置异常！\n"},{"id":49,"href":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/python/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/","title":"编译安装部署","section":"Python","content":"Python 编译安装 #  准备 #  访问 官网找到对应版本（以Python 3.6.5为例）如图：\n下载命令：\nwget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz  安装 #  解压 #  tar -zxvf Python-3.6.5.tgz  准备编译环境 #  yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make  如果python是3.7版本，还需要安装 libffi-devel\n编译 #  cd Python-3.6.5 ./configure --prefix=/usr/bin/python-3.6.5 \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install  其中 --prefix 是 Python 的安装目录，安装成功后如图所示:\n从图中可以看出也同时安装了 setuptools 和 pip 工具\n创建软连接 #  ln -s /usr/bin/python-3.6.5/bin/python3.6 /usr/bin/python3  配置环境变量 #  编辑环境变量文件 ~/.bash_profile\n# 配置python export PYTHON_HOME=/root/training/Python-3.6.5 export PATH=$PYTHON_HOME/bin:$PATH  保存并执行 source ~/.bash_profile，查看是否生效\n参考资料 #   Linux系统安装Python3环境（超详细\n"},{"id":50,"href":"/%E8%AE%BE%E5%A4%87/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/","title":"故障排除","section":"树莓派","content":"\u0026lt;markdown\u0026gt; # 使用树莓派遇见的一些问题的解决方法 ## 不能进入系统 Failed to load SELinux policy. Freezing ### 背景 想关闭 SELinux 结果改错配置项了，导致系统启动时一直提示`Failed to load SELinux policy. Freezing`就是进不去系统。现在进不去系统，配置文件也没法修改，也不想重装系统，遂在网上找了各种方法 1. windows下倒是可以使用DiskGenius来访问ext4格式的文件系统，但是写入的功能是收费的，也没找到破解版，其他软件只支持读取不支持写入； 2. 进入grub编辑的方法我是没弄成功；\n后来突然想到挂载到虚拟机上试试，结果还真成功了，所以在此记录下。\n### 原因 永久关闭 SELinux 时配置错了，应修改的是`/etc/selinux/config`中的`SELINUX`项改为`disabled`，结果错改了`SELINUXTYPE`项，原始配置如下 ``` # This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - No SELinux policy is loaded. SELINUX=enforcing # SELINUXTYPE= can take one of these three values: # targeted - Targeted processes are protected, # minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection. SELINUXTYPE=targeted\n``` ### 解决方法 1. 将TF卡挂载到Linux虚拟机上，方法可以参考[《linux虚拟机上挂载U盘》]( https://jingyan.baidu.com/article/8ebacdf028b13449f65cd5a5.html) 2. 使用`fdisk -l`查看磁盘信息 3. 使用`mount /dev/sdb4 /usb`挂载\n挂载完成后就可以访问磁盘了，进去把配置修改正确再插入树莓派启动，完美！\n\u0026lt;/markdown\u0026gt;\n"},{"id":51,"href":"/%E8%AE%BE%E5%A4%87/%E6%A0%91%E8%8E%93%E6%B4%BE/%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%83%A7%E5%BD%95/","title":"系统的烧录","section":"树莓派","content":"树莓派系统的烧录 #  环境准备 #  系统镜像 #  树莓派有专用的系统 raspbian 可以在其 官网下载。不过我要使用的是 Centos7，系统文件可在其官网的 下载页面进行下载，注意一定要下载 ARM 版本。\n使用的工具 #  SD Memory Card formatter #  这个是用于格式 SD 卡的，它有 Windows 版和 Mac 版，我使用的是 Windows 版。\nwin32diskimager #  这个是用于向 SD 卡烧录系统的，在其 官网下载最新的稳定版就可以，我是用的是 1.0.0 版本。\n烧录 #  格式化 TF 卡 #  将卡连接到电脑上，打开 SD Memory Card formatter。在上面选择要格式化的 TF 卡，其他配置不用调，点击 Format\n烧录系统 #  打开 win32diskimager 在上面选择刚下载的 CentOS 的映像文件，注意旁边的设备不要选错，然后点击写入\n烧录好系统后，在我的电脑可以看到 TF 卡变成一个只有几十 M 的 boot 盘\n开机 #  将烧录完成的 TF 卡插入到树莓派中，同时接上 HDMI 显示器、键鼠，最后接上电源即可开机。\n正常情况下，开机是直接进入到桌面环境，网络连接可以选择接入网线或者连接 wifi。\n**注：centos 的 arm 版本系统默认用户名：root，默认密码：centos **\n扩展系统的硬盘大小 #  开机后发现系统硬盘大小并不是和 TF 一致，这是因为系统是通过 烧录 而不是 安装 进 TF 卡的。在烧录的过程中不会根据 TF 卡的大小建分区表、文件系统，而是把之前预先写好的分区表和文件系统按原样写上去，装完启动后在自己扩大分区和文件系统同。这样的好处是烧录过程非常简单，在任何操作系统下都能正确完成。\n扩展方法 #  使用软件 DiskGenius 修改挂载点 / 的磁盘大小即可。修改方法可以参考 这篇教程\n参考资料 #   树莓派(Raspberry Pi 3)的系统烧录及使用\n树莓派安装系统详细步骤\n树莓派（一）——完整烧录及配置过程（超详细）\n【树莓派】系统安装与初始化配置]\n"},{"id":52,"href":"/%E8%AE%BE%E5%A4%87/%E8%B7%AF%E7%94%B1%E5%99%A8/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8_mini_%E5%88%B7_openwrt/","title":"小米路由器 Mini 刷 Openwrt","section":"路由器","content":"====== 小米路由器 mini 刷 openwrt ======\n将系统刷成开发版 #   在 MiWiFi 下载路由器对应的 ROM 开发版，版本 2.21.109  安装 miwifi_ssh #   在 MiWiFi 开发页面点击 “开启 SSH 工具” 下载 SSH 工具 miwifi_ssh.bin 将路由器绑定小米账号后，在页面会显示 root 的密码 将 miwifi_ssh.bin 放入 U 盘，删除 U 盘上的其他文件，其他操作与刷 ROM 一致  刷成 OpenWrt #  在 OpenWrt 的官网下载对应版本的固件，我的是 小米路由器 MINI，其他型号的路由器可以在官网的 Table of Hardware: Firmware downloads中搜索下载\nscp openwrt*.bin root@192.168.31.1:/tmp cd /tmp mtd -r write openwrt*.bin firmware  如遇以下报错，改 firmware 为 OS1 即可\nCould not open mtd device: firmware Can't open device for writing!  修改官方源 #  注意：不同 CPU 的路由器的 OpenWrt 源的配置不完全相同，需要根据 CPU 的型号来配置，小米路由器 MINI 的 CPU 是 MT7620A\n源配置文件的路径: /etc/opkg/distfeeds.conf，将官方源注释掉后填入下面的源\nsrc/gz reboot_core http://mirrors.ustc.edu.cn/openwrt/releases/19.07.5/targets/ramips/mt7620/packages src/gz reboot_base http://mirrors.ustc.edu.cn/openwrt/releases/19.07.5/packages/mipsel_24kc/base src/gz reboot_luci http://mirrors.ustc.edu.cn/openwrt/releases/19.07.5/packages/mipsel_24kc/luci src/gz reboot_packages http://mirrors.ustc.edu.cn/openwrt/releases/19.07.5/packages/mipsel_24kc/packages src/gz reboot_routing http://mirrors.ustc.edu.cn/openwrt/releases/19.07.5/packages/mipsel_24kc/routing src/gz reboot_telephony http://mirrors.ustc.edu.cn/openwrt/releases/19.07.5/packages/mipsel_24kc/telephony  openwrt 安装中文语言包 #  语言的设置选项在路由的管理界面中 System -\u0026gt; System -\u0026gt; System Properties -\u0026gt; Language and Style -\u0026gt; Language，刚刷完的固件时选项只有英文，其他的需要安装\n自动安装 #  在路由的管理页面中 System -\u0026gt; Software，在 Download and install package 旁边的文本框中输入 luci-i18n-base-zh-cn 点击 OK 系统会自动下载并安装\n参考资料 #   OPENWRT安装中文语言包\nOpenWrt之v2ray安装及配置\n小米路由器 mini 刷 OpenWrt/PandoraBox/LEDE\n 额外记录 #  安装 v2ray #  下载 openwrt-v2ray 和 luci-app-v2ray 到本地（其中的 luci-i18n-v2ray-zh-cn 是中文包，看需求下载）\n将下载的文件上传到路由器中，我执行的安装命令是：\nopkg install v2ray-core-mini_4.34.0-1_mipsel_24kc.ipk opkg install luci-app-v2ray_1.5.6_all.ipk  遇见的问题 #  1. verify_pkg_installable: Only have 11312kb available on filesystem /overlay, pkg v2ray-core needs 12717 #  ~这是因为 /overlay 分区可用空间不够了。\n(1) 修改/etc/opkg.conf，将其中的overlay_root的值修改为/tmp\ndest root / dest ram /tmp lists_dir ext /var/opkg-lists option overlay_root /tmp option check_signature  (2) 保存文件后再执行安装命令，在安装命令后增加-d ram的参数\nopkg install [package] -d ram  详情可参见 这里 这种方法不行。 -d ram 的选项意思是将软件安装到 /tmp 路径下，而 /tmp 则是 tmpfs 类型的文件系统（这个可以使用 df -h 可以看到），是存在内存中的，关机之后就没有了。\n2. satisfy_dependencies_for: Cannot satisfy the following dependencies #  查看内核版本的命令 opkg info kernel\n 快照版本在安装空隙时是否使用官方源有一定的机率出行该问题。 解决的方案是编译阶段就将对应的依赖包安装进去。v2ray并不依赖内核版本\n可以尝试手动安装ip，ipset，iptables-mod-tproxy，dnsmasq-full，resolveip\n然后再安装luci-app-v2ray\n opkg remove dnsmasq opkg install ip ipset iptables-mod-tproxy dnsmasq-full resolveip opkg install luci-app-v2ray  3. [info] Service disabled: main [info] Transparent proxy disabled. #  [info] Service disabled: main [info] Transparent proxy disabled.  这时是已经安装成功了，这提示中的配置可以在 /etc/config/v2ray 中修改。\n4. module \u0026rsquo;luci.cbi\u0026rsquo; not found #  有说需要 安装luci-compat的luci-ap-sqm可以解决，但是使用 opkg 安装提示\nUnknown package 'luci-compat'. Collected errors: * opkg_install_cmd: Cannot install package luci-compat.   解决方法\nopkg update opkg install luci luci-base luci-compat  5. #  Collected errors: * satisfy_dependencies_for: Cannot satisfy the following dependencies for v2ray-core: * ca-certificates * opkg_install_cmd: Cannot install package v2ray-core.  执行 opkg update 后再安装一下\n参考资料 #   编译Openwrt固件安装软件内核版本不一致问题解决\nOpenWRT内核不符合依赖\n"},{"id":53,"href":"/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/let_s_encrypt%E5%85%8D%E8%B4%B9ssl%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E4%B8%8E%E7%BB%AD%E6%9C%9F/","title":"Let's Encrypt 免费 SSL 证书申请与续期","section":"其他","content":"Let\u0026rsquo;s Encrypt 免费 SSL 证书申请与续期 #   Let\u0026rsquo;s Encrypt 是一个于2015年三季度推出的数字证书认证机构，旨在以自动化流程消除手动创建和安装证书的复杂流程，并推广使万维网服务器的加密连接无所不在，为安全网站提供免费的传输层安全性协议（TLS）证书。\nLet\u0026rsquo;s Encrypt 由互联网安全研究小组（缩写 ISRG）提供服务。主要赞助商包括电子前哨基金会、Mozilla 基金会、Akamai 以及思科。2015年4月9日，ISRG 与 Linux 基金会宣布合作。\nLet\u0026rsquo;s Encrypt 宣称这一过程将十分简单、自动化并且免费。\n安装 certbot #  certbot 是 Let\u0026rsquo;s Encrypt 的客户端。我的系统是 Centos，使用的是下面的命令\nyum install -y certbot  使用 certbot --version 查看版本显示\ncertbot 1.12.0  是此时的最新版。如果不是还可以使用手动安装的方式，在 这里下载最新的发布包解压即可。\n申请 ssl 证书 #  申请的命令格式一般是\ncertbot certonly -d \u0026#34;*.youdomain.com\u0026#34; --manual --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory 其中：\n certonly，表示使用的插件，Certbot 有很多插件。不同的插件都可以申请证书，这个可以根据需要自行选择。 -d，为哪些主机申请证书。如果是通配符，输入 *.youdomain.com（根据实际情况替换为你自己的域名）。 –preferred-challenges，使用 DNS 方式校验域名所有权。注：申请通配符证书，只能使用 dns-01 的方式。 –server，Let’s Encrypt ACME v2 版本使用的服务器不同于 v1 版本，需要显示指定  我使用的命令的是\ncertbot certonly -d \u0026#34;*.coderqs.com\u0026#34; --manual --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory 输入上述命令后，会有如下提示：\n Saving debug log to /var/log/letsencrypt/letsencrypt.log Plugins selected: Authenticator manual, Installer None Enter email address (used for urgent renewal and security notices) (Enter \u0026#39;c\u0026#39; to cancel): youemail@domain.com - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Please read the Terms of Service at https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You must agree in order to register with the ACME server. Do you agree? - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - (Y)es/(N)o: Y - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Would you be willing, once your first certificate is successfully issued, to share your email address with the Electronic Frontier Foundation, a founding partner of the Let\u0026#39;s Encrypt project and the non-profit organization that develops Certbot? We\u0026#39;d like to send you email about our work encrypting the web, EFF news, campaigns, and ways to support digital freedom. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - (Y)es/(N)o: Y Account registered. Requesting a certificate for *.coderqs.com Performing the following challenges: dns-01 challenge for coderqs.com - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Please deploy a DNS TXT record under the name _acme-challenge.coderqs.com with the following value: 5kugLqDPaeD3hEYZl2bHae0VgQoRUt1if39LbuQnr_A Before continuing, verify the record is deployed. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Press Enter to Continue 上面的邮箱输入你自己常用的，其他的都输入 Y 就可以，但是要注意最后一条，先不要着急按回车\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Please deploy a DNS TXT record under the name _acme-challenge.coderqs.com with the following value: 5kugLqDPaeD3hEYZl2bHae0VgQoRUt1if39LbuQnr_A Before continuing, verify the record is deployed. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Press Enter to Continue 这里是让你在你的域名管理器中添加一条 TXT 记录来证明这个域名是你的（如果这里你手快按了回车，一定要再执行一遍命令，因为让你添加的 TXT 的值会改变，像上面的提示要添加的 TXT 是主机名为_acme-challenge，内容为 5kugLqDPaeD3hEYZl2bHae0VgQoRUt1if39LbuQnr_A 的记录）。添加完 TXT 后，需要等待其生效后再在这里按回车即可（certbot 已经自动退出的话可以再执行一遍命令，一般客户端自动退出时候字符串的值是不会变的）。\n注：等待 TXT 修改生效的时间会比较长，可以使用 [[|nslookup]] 来查看 TXT 有没有生效，我使用的命令如下（此命令 windows 与 linux 都支持）\n nslookup -qt=txt _acme-challenge.coderqs.com 当其类似如下显示时既是已生效\n *** Invalid option: qt=txt Server: UnKnown Address: 82.163.142.9 Non-authoritative answer:: _acme-challenge.coderqs.com text = \u0026#34;IMdfdsfsJDqBRyRaaEgPPQlEuvtxJQAgWZTIVbLuzDi8U\u0026#34; 证书续期 #  Let\u0026rsquo;s Encrypt 的证书有效期是 90 天，允许提前 30 天续签，执行下面命令会续签所有的证书\n certbot renew 将该命令添加到 crontab 中可以实现自动续签。\n遇见的问题 #  no package certbot available #  在 Centos7 上安装时提示no package certbot available，原因不明\n解决方法 #   sudo yum -y install yum-utils sudo yum -y install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm sudo yum-config-manager -y --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional sudo yum -y install certbot 参考自 CentOS 7: No package certbot available. #3257\n续签失败 #  续签失败错误提示：\n Could not choose appropriate plugin: The manual plugin is not working; there may be problems with your existing configuration. The error was: PluginError(\u0026#39;An authentication script must be provided with --manual-auth-hook when using the manual plugin non-interactively.\u0026#39;,). Skipping. 原因是申请时没有指定 --manual-auth-hook 参数\n解决方法 #  加上 --manual-auth-hook 参数重新申请一遍\n参考资料 #   Let\u0026rsquo;s Encrypt - 维基百科\nLet\u0026rsquo;s Encrypt免费申请SSL证书\nNginx启用Let’s Encrypt SSL证书\n在macOS平台下制作SSL证书，免费域名通配符证、单域名证书、多域名证书教程\nLetsencrypt通过DNS TXT记录来验证域名有效性\n"},{"id":54,"href":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3/","title":"Linux 下的问题及解决方法 - 用户相关\"","section":"故障排除","content":"Linux 下用户相关的的问题解决方法 #  登录用户出现-bash-4.2$ #  原因 #  用户家目录下的环境变量文件（.bash_profile 和 .bashrc）丢失了\n解决方法 #  从主默认文件/etc/skel/下重新拷贝一份配置信息到此用户的家目录下，命令如下\ncp /etc/skel/.bashrc /home/user/ cp /etc/skel/.bash_profile /home/user 拷贝完后注销并重新登录用户即可。\n"},{"id":55,"href":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/","title":"Linux 下的问题及解决方法 - 系统相关","section":"故障排除","content":"Linux 系统相关的问题及解决方法 #  防火墙已开启但没有开放 22 端口，却依然可以使用 ssh 连接 #  原因 #  防火墙开放了 ssh 服务，服务把 22 端口开放了。相关的操作可参考防火墙的 firewalld的规则配置#服务管理\nifconfig 获取不到ip #  原因 #  NetworkManager 断开或没有管理网卡设备。使用 nmcli d status 可以查看 NetworkManager 状态。添加管理和启动的方法请查看《 CentOS7重启后dhclient未运行，导致IP未获取问题处理》\nsystemctl 报错 code=exited status=203 #  原因 #  systemctl 执行脚本时需要知道脚本的解释器。\n解决方法 #  脚本启动命令前指定脚本的解释器，可以参考实例记录: linux脚本自己可以单独执行但在service文件中使用就错误。\n"},{"id":56,"href":"/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/openssl%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6/","title":"OpenSSL 自签证书","section":"其他","content":"OpenSSL 自签证书 #  检查OpenSSL #  检查是否已经安装openssl：\nopenssl version 一般情况下系统会默认安装。\n生成自签名的SSL证书和私钥 #  1. 生成私钥 #  openssl genrsa -des3 -out server.pass.key 2048 参数解析:\n genra 生成RSA私钥 -des3 des3算法 -out server.key 生成的私钥文件名 2048 私钥长度  2. 去除私钥中的密码 #  openssl rsa -in server.pass.key -out server.key 注意：有密码的私钥是server.pass.key，没有密码的私钥是server.key\n3. 生成CSR(证书签名请求) #  openssl req -new -key server.key -out server.csr -subj \u0026#34;/C=CN/ST=Guangdong/L=Guangzhou/O=xdevops/OU=xdevops/CN=gitlab.xdevops.cn\u0026#34;  req 生成证书签名请求 -new 新生成 -key 私钥文件 -out 生成的CSR文件 -subj 生成CSR证书的参数  subj 参数说明如下：\n   字段 字段含义 示例     /C= Country 国家 CN   /ST= State or Province 省 Guangdong   /L= Location or City 城市 Guangzhou   /O= Organization 组织或企业 xdevops   /OU= Organization Unit 部门 xdevops   /CN= Common Name 域名或IP gitlab.xdevops.cn    4. 生成自签名SSL证书 #  openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt  -days 证书有效期 x509 证书的格式  补充 #  1. 从命令行中使用密码生成私钥 #  使用参数 -passout，可以从命令行、文件、标准流输入密码\n命令行 #  openssl genrsa -aes128 -passout pass:password 3072 文件 #  openssl genrsa -aes128 -passout file:password.txt 3072 标准流 #  echo \u0026#34;password\u0026#34; | openssl genrsa -aes128 -passout stdin 3072 注意：-passout 参数一定要在参数-out和加密位数之前，否则不生效\n @Mawg: OpenSSL doesn\u0026rsquo;t like it if the -out param comes after the 2048 - really, that\u0026rsquo;s supposed to be the last thing on the command line (I\u0026rsquo;ve updated my answer as such). See the last example, I think that\u0026rsquo;s what you want. As for AES-128, someone I trust in these matters recommends it over AES-256.\n 参考自： How to generate an openSSL key using a passphrase from the command line?\n"},{"id":57,"href":"/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/pandoc/","title":"Pandoc","section":"其他","content":"Pandoc #  提供多种标记语言之间的转换的功能，但不完全是双向的，部分是单向的，可转换的关系请参考 此页面。\n使用 #  较短的文字可以使用 在线版来转换，文字过长就需要 下载客户端来转换。\nmarkdown 转 dokuwiki #   pandoc -f markdown_github -t dokuwiki in_filename.md -o out_filename.txt  注：markdown 的语法分支比较多，要选对自己使用的是那种 markdown 语法。\n参考资料 #   Pandoc 用户指南\n"},{"id":58,"href":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/shell%E7%9B%B8%E5%85%B3/","title":"Shell 脚本相关的问题的解决方法","section":"故障排除","content":"Shell 脚本相关的问题的解决方法 #  \u0026ldquo;-bash: !\u0026rdquo;: event not found #  原因 #  ! 是 bash 的特殊字符，用于引用之前以!后面字符串开头的最后一个的命令。\n!$ 是获取上一条命令的最后一个参数。\n注意：在脚本中，所有历史命令都被禁用，因为它们只在交互式 shell 中才有意义\n解决方法 #  方法一 #  执行 set +H 临时关闭该功能\n方法二 #  将该字符串用单引号括起来，双引号不可以\n方法三 #  在 ! 前添加\\或后面添加空格，但这种方法有额外的字符混进去，所以如果是输入密码的时候出现的问题，这种方法是不可用的。\n参考自 What is “-bash: !”: event notfound\u0026quot;\n"},{"id":59,"href":"/%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E6%9C%BA/vmware/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/","title":"VMware 遇见的问题及解决方法","section":"Vmware","content":"VMware 遇见的问题及解决方法 #  虚拟机繁忙无法关机 #  这种问题出现的原因不明（有看到一些说法是 Windows 10 的某些版本和 VMware 兼容性的问题导致的，但也没找到明确的证据证明，都是凭感觉m(）\n解决方法 #  1. 在任务管理器中关闭 vmware workstation vmx.exe 进程\n2. 但我在这个地方遇到了问题：就是这个进程根本关不掉！！尝试了各种方法都关不掉！！网上有帖子说 是1903版本与vmware的兼容性问题，但也没有给出解决方案。\n3. 通过 Windows 程序与功能将 VMware 修复(没有必要重装，一定不要动原来的虚拟机文件）。修复完成后，虚拟机就可以重新启动了。\n参考自： Vmware Workstation虚拟机繁忙导致无法关机\n"},{"id":60,"href":"/%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/wireshark/%E5%B8%B8%E7%94%A8%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6/","title":"Wireshark 常用过滤条件","section":"Wireshark","content":"Wireshark 常用过滤条件 #  根据地址 #  指定 IP #  ip 192.168.1.1 指定源 IP #  ip.src 192.168.1.1 指定目标 IP #  ip.dst 192.168.1.1 指定端口 #  指定 TCP 协议的端口 #  tcp.prot 8080 指定 UDP 协议的端口 #  udp.prot 8080 指定源端口(以TCP协议为例) #  tcp.srcport 8080 指定目标端口(以TCP协议为例) #  tcp.dstport 8080 根据时间 #  某一时刻的数据包 #  frame.time == \u0026#34;May 27, 2019 15:23:57.932344000\u0026#34; 某一时刻之后的数据包 #  frame.time \u0026gt;= \u0026#34;May 27, 2019 15:23:57.0\u0026#34; 某一时间内的的数据包 #  frame.time \u0026gt;= \u0026#34;May 27, 2019 15:23:57.0\u0026#34; \u0026amp;\u0026amp; frame.time \u0026lt; \u0026#34;May 27, 2019 15:23:58.0\u0026#34; 参考资料 #   wireshark 报文分析\u0026mdash;根据时间（Arrival Time）过滤报文\n"},{"id":61,"href":"/%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/wireshark/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/","title":"Wireshark 遇见的问题的解决办法","section":"Wireshark","content":"Wireshark 遇见的问题的解决办法 #  选择网卡时卡死无响应 #  在选择网卡后 Wireshark 就会卡死，然后进程未响应，重新打开又重复的卡死无响应的过程。打开任务管理器发现 Wireshark 内存占用迅速上涨，我这里是上涨了 1G 多。\n这个跟 TLS 有关。因为我之前弄 webrtc 的时候配置了 https 的解密，并且没有还原配置，然后我浏览器有很久没有重启，导致浏览器的 sslkeylogfile 文件变得很大，而 Wireshark 开始抓包的时候会循环读取 sslkeylogflie 的内容，所以就出现卡死与崩溃的情况。\n解决方法 #  方法一 #  重启浏览器，删除 sslkeylogflie 文件。这是临时解决方法，当 sslkeylogflie 文件变大后还是会出现这个问题。\n方法二 #  还原 Wireshark 中关于 TLS 的配置。配置路径 编辑-\u0026gt;首选项-\u0026gt;Protocols-\u0026gt;TLS 。\n参考资料 #   《Dive into Windbg系列》Wireshark的卡死与崩溃\n"}]